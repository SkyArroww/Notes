![[Pasted image 20240411170439.png]]
# 一面
上来先放了一套题让做，1h，内容涵盖语言基础、改错、算法等等(我答的稀碎)
正式面试35min
### 1. C++里的虚函数  实现原理
C++中的虚函数是**通过虚函数表实现**的。每个含有虚函数的类都有一个虚函数表，其中存放了该类中的虚函数地址。在类的构造对象时，编译器会**在对象的内存空间中添加一个指向其虚函数表的指针指针，即虚指针**，这个指针指向该类的虚函数表，在子类中覆盖了基类的虚函数，则**新的子类的虚函数地址将被存放在虚函数表的对应位置中**，即通过虚指针和虚函数表，实现动态绑定，使调用合适的子类虚函数。
当一个类中包含虚函数时，编译器会为该类生成一个虚函数表。下面是一个使用虚函数的例子：

```c
class Shape {
   public:
      virtual void draw() {
         cout << "Drawing a generic shape" << endl;
      }
};

class Rectangle: public Shape {
   public:
      void draw() {
         cout << "Drawing a rectangle" << endl;
      }
};

class Circle: public Shape {
   public:
      void draw() {
         cout << "Drawing a circle" << endl;
      }
};

int main() {
   Shape* shape;
   Shape genericShape;
   Rectangle rectangle;
   Circle circle;
   
   shape = &genericShape;
   shape->draw(); // Output: Drawing a generic shape
   
   shape = &rectangle;
   shape->draw(); // Output: Drawing a rectangle
   
   shape = &circle;
   shape->draw(); // Output: Drawing a circle
   
   return 0;
}

```

在上面的例子中，Shape类中的draw()函数被声明为虚函数，Rectangle和Circle类都继承自Shape类并重写了draw()函数。main函数中使用了多态机制，通过Shape指针访问派生类的重写方法时，运行时将会根据对象类型的实际类型，动态选择哪个版本的函数进行调用，在这里是动态绑定到Rectangle的draw()函数和Circle的draw()函数。
如果一个函数被声明为虚函数，则其派生类中同名函数都是虚函数，因为它们**共享同一个虚函数表**。同时，**虚函数的调用会导致额外的时间、空间开销**，因此在实现时需要谨慎使用。

### 2. 虚函数表会在每个类对象中都存一份吗?
不是的，每个含有虚函数的类都有一个**唯一的虚函数表，存储着类的虚函数地址**。而每个类的**对象中都含有一个虚指针**（也称为虚函数表指针），指向该类的虚函数表。

当通过一个指向基类的指针或引用调用一个虚函数时，编译器会根据该指针或引用所指向的对象实际的类型，通过该对象类型的虚函数表寻找该虚函数的实际地址，从而保证调用到正确的虚函数，这就是虚函数的动态绑定的实现原理。

因此，一个基类的指针或引用可以同时指向该基类的对象或其派生类的对象，通过它们的虚指针可以找到各自的虚函数表，从而正确地调用各自的虚函数。

### 3. 函数重载和函数重写
函数重载（Function Overloading）和函数重写（Function Overriding）是两个不同的概念。
1. 函数重载  
    函数重载指**在同一作用域内，函数名相同但形参列表不同的多个函数**，可以是同一个类中的成员函数，也可以是不同类的成员函数或普通函数。
	函数重载是静态多态性（Compile-time Polymorphism）的一种实现方式。在编译时，编译器 会根据调用的具体情况，确定使用哪个具体的函数，这种**在编译时确定调用方式的多态性称为静态多态性**。
1. 函数重写  
    函数重写指**在派生类中重新定义其基类的虚函数的过程**。派生类**重写的函数必须和基类虚函数在函数名、参数列表、返回类型和const修饰符上完全一致**。如果函数签名不一致则不是函数重写，而是函数隐藏。
	函数重写是**动态多态性**（Dynamic Polymorphism）的一种实现方式。在运行时，根据对象具体的类型，选择对应的函数实现，这种在运行时确定调用方式的多态性称为动态多态性。

总之，函数重载是静态多态性的一个实现方式，与函数的virtual关键字无关，函数重写是动态多态性的一种实现方式，需要使用virtual关键字定义虚函数。

### 4. vector的底层实现
vector是C++ STL标准库中的一个类模板，可以看做是动态数组。
vector的底层实现使用了**连续的线性存储空间**，即在内存中分配一块连续的空间用于存储元素。当需要添加新元素时，**vector会先检查是否有足够的剩余空间，如果没有，则重新分配一块更大的空间，并将原来的元素复制到新的空间中，然后释放原来的空间。**
vector中的元素是按照顺序存储的，可以通过下标或迭代器进行访问，支持随机访问。
除了动态增加存储空间，vector还提供了很多其他操作，如元素的插入、删除、查找等等。同时，vector的底层实现还保证了不仅仅在元素数量上具有可扩展性，还在元素类型（指针、引用、类等）上具有可扩展性。

总之，vector的底层实现确保了其高效的动态存储和遍历元素，是C++中重要的数据结构之一。

### 5. vector的扩容机制
vector在存储元素时，底层使用一块连续的内存空间进行存储。当向vector中添加新元素时，如果当前的内存空间不够用了，vector就需要进行扩容，即重新分配更大的内存块，并将原有的元素复制到新的内存块中。
vector扩容的机制如下：
1. 当vector的size元素数量超过capacity容量时，需要进行扩容。
2. vector会重新分配一块更大的内存块，一般是**当前的容量的两倍**。
3. vector将原有的元素复制到新的内存块中。
4. 释放原有的内存空间。
5. 将新分配的内存空间赋值给vector的内部指针。

需要注意的是，vector扩容时需要进行内存分配和元素复制，这是一项比较耗时的操作。因此，在使用vector时，建议预留一定的空间，避免过于频繁的扩容操作，提高vector的性能。可以**通过reserve()函数**来提前预留空间，避免频繁的内存分配。

### 6. map底层实现
map是C++ STL标准库中的一个关联式容器，可以用来存储键值对。其底层是基于**红黑树**实现的。
红黑树是一种**自平衡二叉搜索树**，可以**在 $O(log n)$的时间内完成插入、删除和查找等操作**。在map中，每个节点都代表一个键值对，红黑树**按照键值进行排序**，键是唯一的且不可修改。通过融合了平衡性和快速查找的特点，map实现了高效的查找和插入操作，支持快速访问、删除和修改键值对。
map底层的实现基于红黑树的数据结构，这个数据结构被封装成了一个类模板，通过类模板参数可以指定键值类型和比较函数类型等信息。对于所有要存储的键值对，map都将其插入到红黑树中，并以键进行排序。通过红黑树自平衡的能力，在执行插入、删除和查找等操作时保持树的平衡，达到O(log n)的时间复杂度。
总之，map是一种高效的关联式容器，在存储键值对时基于红黑树实现。它具有高效的查找、插入和删除操作，支持快速访问、删除和修改键值对。

### 7. 红黑树的特性有哪些?
红黑树是一种特殊的自平衡二叉搜索树，满足以下五个性质：
1. 每个节点要么是红色，要么是黑色。
2. **根节点是黑色的**。
3. 每个**叶子节点（空节点）是黑色**的。
4. 如果**一个节点是红色的，则它的两个子节点都是黑色**的。
5. 对于任意节点来说，从**该节点到其所有后代叶子节点的路径包含相同数目的黑节点**。
这五个性质的作用是：
1. 第1、2性质保证了根节点和空节点是黑色的，从而确保了红黑树的红黑平衡。
2. 第3性质保证了叶子节点是黑色的，从而简化了某些操作。
3. 第4性质保证任何一个节点的两个子节点不会同时为红色，避免了相邻节点都为红色的情况，使红黑树保持了平衡。
4. 第5性质保证了所有路径的长度差不会太大，使得树在保持平衡的同时，具有了良好的查找性能，时间复杂度为 O(log n)。

红黑树是一种自平衡的二叉搜索树，具有良好的查找、插入和删除复杂度，应用于很多场景，比如C++中的map和set，Java中的TreeMap和TreeSet等。

### 8. vector和list的区别
vector和list都是STL提供的容器，但两者有很大的区别，主要体现在：
1. 内存分配方式不同：**vector使用连续的内存空间**存储元素，而**list使用链表**的方式，每个节点存储一个元素；
2. 访问元素的速度不同：**vector的元素是连续的，可以通过下标随机访问元素**，并且支持快速的首尾元素操作，所以访问元素速度比较快；而**list不支持随机访问，只能顺序访问元素**，每次访问需要从头或从尾开始遍历链表，因此访问元素速度比较慢；
3. 插入和删除的效率不同：向vector中插入或删除元素，需要移动数组中的元素，因此效率较低；而向list中插入或删除元素，只需要修改节点的指针，效率比较高，尤其是在中间插入或删除元素时；
4. 迭代器的失效情况：vector插入或删除元素时，会造成迭代器的失效，因为插入或删除元素会改变整个vector中元素的位置，而list插入或删除元素时，迭代器不会失效，因为插入或删除元素只是改变相邻节点的指针，不影响其他节点的指针。

综上所述，vector适用于在末尾进行插入和删除的操作，而且需要随机访问元素的时候；而list适用于经常在中间进行插入和删除操作，并且不需要随机访问元素的时候。

### 9. new和malloc的区别
new 和 malloc 都可以用来**在堆（heap）中动态分配内存**，但二者有以下区别：
1. **new 是C++的运算符**，而**malloc属于C标准库函数**，因此new可以使用C++的运算符重载特性，对于**自定义数据类型，new会自动调用该类型的构造函数**，而**malloc仅分配内存空间**，不会调用构造函数；
2. **new 操作符会返回与申请的类型相匹配的指针**，而**malloc只返回void指针**，需要使用强制类型转换来将其转换为与申请类型相匹配的指针；
3. new 操作符不仅可以分配内存，还可以**创建对象**，使用起来更方便，而**malloc只能分配内存**，而且需要引入stdlib.h这个头文件；
4. **new 操作符具有异常处理机制，当内存分配失败时，会抛出异常**，而**malloc没有异常处理机制**，需要我们手动判断是否分配成功。

综上所述，对于C++程序，**首选使用new和delete来动态分配和释放内存空间**，因为它更加灵活、方便、安全，同时能够避免一些不必要的错误。如果是在C程序中，应该使用malloc和free。

### 10. C++里堆和栈的区别
在C++中，堆（heap）和栈（stack）都是内存空间，它们的区别如下：
1. 内存分配方式不同：**栈空间是LIFO**（后进先出）的，程序在函数内部自动为局部变量分配栈空间，当局部变量超出作用域时，栈自动释放空间。堆空间是程序显式地分配和释放的，程序员需要手动在堆上为指定大小的内存请求分配空间，并在不需要时显示释放。
2. 内存管理方式不同：**栈空间由编译器管理，自动分配和释放**。堆空间需要程序员手动管理**，申请、释放等操作由程序员控制。
3. 内存大小限制不同：**栈空间相对较小**，大小由操作系统的内存分配规则决定；而**堆空间大小较大**，取决于计算机的物理内存大小（虚拟内存等）。
4. 变量访问方式不同：从**栈中分配的变量可以更快地访问**，因为它们的内存位置是固定的，并可**利用CPU的指针寄存器**来访问；而从**堆中分配的变量则需要经过一定的寻址运算**，速度相对较慢。

总之，堆和栈都有各自的优势和不足，选择使用哪个取决于具体的应用场景和需求。通常情况下，我们将**较小、较短寿命的变量分配到栈中，较大、较长寿命的变量分配到堆中**，以充分利用内存资源。

### 11. 可以手动在栈上申请内存吗
在C++中，我们通常不需要手动在栈上申请内存，因为栈的空间由编译器在函数调用时自动分配和释放。局部变量、函数参数等都是在栈上进行分配的。这些变量的声明和使用都是在程序编译阶段就被确定的，程序在运行时会自动为其分配内存空间，函数执行完毕后，栈空间会自动释放。因此，我们不需要也不应该手动在栈上申请内存。

相反，如果需要手动分配内存，常用的方法是使用自由存储区（堆），可以使用new和malloc等方法手动分配空间。但需要注意的是，手动分配内存需要我们手动释放，否则会造成内存泄漏问题。因此，为了避免内存泄漏，应该在合适的时候释放手动分配的内存，以免占用过多的内存资源。

### 12. `#define` 和 `typedef` 
`#define`和`typedef`都是C++中用于定义符号常量或类型别名的预处理指令，但它们的使用方式和用途略有不同。
不同点：
- `#define`是**用来定义符号常量的预处理指令**，它没有类型检查，可以定义任何类型的符号常量。`typedef`是**用来定义类型别名的预处理指令**，只能用来定义类型别名，不可以用来定义符号常量。
- 在使用和定义上，`#define`不需要使用分号结尾，而`typedef`需要使用分号结尾。

相同点：
- `#define`和`typedef`都是C++中用于对代码进行宏定义的预处理指令，其定义的标识符在代码中会被替换成定义的常量或类型。
- 二者都可以提高代码的可读性、可维护性和可重用性。

虽然`#define`和`typedef`有着不同的应用场景，但它们的共同目标都是使代码更加清晰简洁。因此，在实际开发中，应该灵活选择并根据实际情况选用适当的预处理指令来优化代码。

### 13. 给定10000个数求最大3个
对于求解最大的三个数问题，常见的解法有冒泡排序、插入排序、快速排序、堆排序、基数排序等多种算法。这些算法的时间复杂度都介于O(n log n)和O(n^2)之间。由于给定10000个数字，算法的时间复杂度需要控制在O(n log n)以下，因此，需要从算法的性能和时间复杂度出发，选择最合适的算法。
从时间复杂度角度出发，如果快速排序、堆排序等O(n log n)级别的算法已经无法满足要求，那么可以考虑基数排序等O(n)级别的排序算法，以最快的速度解决问题。
另外，如果要求最大的前K个数，也可以使用堆这种数据结构。堆常用来维护一组数据中的最大或最小值，应用场景广泛，比如求最小的前K个数问题以及求最大的前K个数等问题。
在本题中，可以利用堆的特性，维护一个最小堆，堆顶元素为堆中最小的元素。遍历数据集合，对于每个元素，如果堆的大小小于3，则直接加入堆中，否则判断该元素是否大于堆顶元素，若是，则将堆顶元素弹出，将该元素加入堆中。这样遍历完成后，堆中的三个元素就是数据集合中最大的三个数。由于堆的大小不超过3，因此算法时间复杂度为O(n log 3)。

### 14. 快排大致原理
快速排序是一种常用的排序算法，其基本思路是**分治**，通过将一个问题划分为多个子问题，逐个解决子问题来最终解决整个问题。
快排的基本原理如下：
1. 在待排序序列中**选择一个元素作为基准元素**（通常选取第一个元素），称为pivot。
2. 把待排序序列中**小于pivot的元素移动到其左侧，把大于pivot的元素移动到其右侧**，从而把序列分成两个子序列。这个过程称为划分(partition)，可以使用两个指针left和right分别从序列两端开始，移动比较，交换元素位置。
3. 对于两个子序列分别进行上述操作，把子序列中的元素分为小于基准元素和大于基准元素的两个子序列。重复上面的操作，直到整个序列都有序。

具体的快排过程如下：
1. 选定pivot，并把待排序序列分为左半部分小于pivot，右半部分大于pivot。
2. 对左半部分和右半部分分别调用递归函数进行排序。
3. 递归结束后，整个序列就有序了。

快排的时间复杂度为O(nlogn)，是一种高效的排序算法，但最坏情况下的时间复杂度为O(n^2)。因此，在实际应用中，需要对算法进行优化，比如在选择pivot时，采用随机或者中位数来减少最坏情况下的出现概率。

### 15. 快排时间复杂度
**快速排序的平均时间复杂度为$O(nlogn)$，最坏时间复杂度为$O(n^2)$，最好时间复杂度为$O(n)$。**
其平均时间复杂度的计算可以理解为，每次划分都能将序列分成一个长度大约为$\frac{n}{2}$的子序列和一个长度大约为$\frac{n}{2}$的空序列。如果快排运行良好，则可以每次把空序列的长度减半，因此快排的时间复杂度可以写成这样的递归式：

$$T(n) = T(\frac{n}{2}) + T(\frac{n}{2}) + O(n)$$

使用主定理可以证明，这个递归式的解为$O(nlogn)$。

但是，当选取的基准元素极端不好（如每次都选取最大或者最小元素）时，快速排序的时间复杂度会变成$O(n^2)$。因此，在实际应用中，需要对排序算法进行优化，比如随机选取基准元素、使用三数取中法或者九数取中法等来选取基准元素，减少最坏情况的出现概率。

### 16. 快排稳定性如何
快速排序是一种不稳定的排序算法。**不稳定的含义是，在排序过程中，如果有两个元素的值相等，它们在排好序的序列中可能会发生交换，从而改变它们的相对位置。**

快速排序的不稳定性源于它的划分过程。在划分过程中，选取一个基准元素，把比它小的元素放在它的左边，把比它大的元素放在它的右边。但是，当序列中有多个元素的值相等时，它们可能会被放到基准元素的左边或右边，并且它们之间的相对位置可能会改变。因此，快速排序是一种不稳定的排序算法。

尽管快速排序不稳定，但由于它的时间复杂度低，因此在大多数情况下，人们仍然使用它来进行排序。如果对于需要稳定排序的问题，可以考虑使用其他稳定的排序算法，如归并排序等。

### 17. 堆排了解过吗?大致原理
堆排序是一种基于堆的选择排序算法。它利用了堆的性质来进行排序，具有时间复杂度O(nlogn)。

堆是一种特殊的完全二叉树，具有以下两个性质：
1. 堆的顶部元素（即根节点）是最大（或最小）的元素。
2. 对于堆中的任何一个非根节点i，它的值都不大于（或不小于）它的父节点的值。

堆排序的基本思想是**先利用堆把序列构建成一个最大堆，然后将堆顶元素与序列的末尾元素交换位置，将末尾元素从堆中移除，再将剩余的序列重新构建成最大堆**，如此往复，直到排序完成。

堆排序的具体步骤如下：
1. 将待排序的序列构造成一个最大堆。
2. 将堆顶元素（即当前序列中最大的元素）与序列末尾元素进行交换。
3. 将新的序列重新构造成一个最大堆。
4. 对剩余的元素重复上述步骤，直到序列已排序。

堆排序的优点是不需要额外的空间来存储排序结果，缺点是对于小规模的数据排序效率较低。

### 18. shared_ptr了解过吗？大致说说
shared_ptr是C++11标准库中的一个**内存管理类**，它是一种**智能指针**（smart pointer），能够**自动管理指向动态分配内存的指针，并确保在不再需要使用这些指针时，也能自动释放分配的内存**。

shared_ptr在内部使用一个引用计数来实现内存的自动管理。它的构造函数接受一个指针作为参数，并将这个指针所指向的动态内存分配出来，并初始化引用计数为1。当使用shared_ptr进行拷贝构造或赋值操作时，引用计数会递增，当引用计数减少到0时，shared_ptr会自动释放指向的内存。

shared_ptr的使用也非常简单，只需要使用它的构造函数来创建智能指针，并在需要使用动态内存的地方使用它即可。例如：

```c++
#include <iostream>
#include <memory>

int main()
{
    std::shared_ptr<int> ptrA(new int(42));
    std::shared_ptr<int> ptrB(ptrA);
    std::cout << "ptrA count = " << ptrA.use_count() << std::endl;
    std::cout << "ptrB count = " << ptrB.use_count() << std::endl;
    return 0;
}

```

在这个例子中，我们创建了一个指向int类型的动态内存的shared_ptr，然后使用它进行了拷贝构造，并输出了当前的引用计数。由于ptrA和ptrB都指向同一个动态内存的空间，因此引用计数为2。

shared_ptr的优点是能够避免内存泄漏，同时也能够避免多次释放同一块内存的错误，从而确保内存的安全和高效的使用。因此，在C++中使用shared_ptr已经成为了一种很好的内存管理方式。

### 19. 说说Dijkstra
Dijkstra算法也称为**单源最短路**径算法，是解决**有权图（带权图）最短路径问题**的一种经典算法。它是基于贪心思想的，通过对图中的所有顶点进行遍历，逐步寻找源点到各个节点的最短路径。Dijkstra算法是一种广泛应用的寻找最短路径的算法，可以用于有向图和无向图，无负权边和非负权边。

具体算法流程如下:
1. 将源点的距离设置为0，其他顶点的距离设置为无穷大，所有顶点的已知最短距离设置为0。
2. 选择距离源点最近的未标记顶点作为当前顶点。
3. 计算从当前顶点到相邻顶点的距离和。
4. 如果新计算的距离小于原距离，则更新最短距离。
5. 当所有顶点都被标记时，算法结束。

Dijkstra算法的时间复杂度为O（n^2），但可以通过使用堆等数据结构来实现优化。

总的来说，Dijkstra算法是一种比较简单但实用的最短路径算法，适用于求解起点到一个或多个顶点之间的最短路径。

### 20. `A*`算法了解吗
`A*`算法是一种**启发式搜索**算法，常被用于解决**具有图形结构的有向图**的最短路径问题。该算法综合了Dijkstra算法的广度优先搜索和贪心算法的启发式搜索，通过尽量沿着最大有可能到达目标的路径搜索，以达到快速找到最短路径的目的。

`A*`算法使用了**两个函数进行辅助决策，分别是启发函数h(n)和代价函数g(n)**。其中，**启发函数h(n)用来评估每个状态到目标状态的距离，代价函数g(n)则表示从起点到状态n的开销**，也即已知路径。

`A*`算法的具体实现流程如下：
1. 初始化起点的g(n)为0，将起点加入到openlist中，同时初始化f(n)为h(n) + g(n)。
2. 重复以下步骤，直到找到终点或openlist为空
- 在openlist中选择f(n)最小的节点n，将其从openlist中删除，并将其加入到closedlist中。
- 对于n的每个邻居m，如果m不在closedlist中，计算它的f(m)值，并更新m的父节点为n，同时将m添加到openlist中。
3. 如果找到了终点，通过回溯从终点到起点，依次得到最短路径上的节点。

`A*`算法的时间复杂度取决于启发函数的精度，使用较为精确的启发函数可以使得算法的时间复杂度明显降低。`A*`算法在多种领域，如游戏AI、机器人规划等方面都有广泛的应用。
### 21. 线程和进程的区别
线程和进程是操作系统中的两个重要概念，它们之间的主要区别如下：

1. **线程是程序执行的最小单位，而进程是操作系统资源分配的最小单位。一个进程可以包含多个线程**。
2. **进程占有独立的内存空间，而线程与它所属进程共享同一内存空间**。因此，同一进程的线程之间可以方便地进行数据共享和通信。
3. 调度和切换的粒度不同。操作系统可以在进程之间进行切换，也可以在同一进程内的不同线程之间进行切换。但由于线程切换需要保存和恢复更少的上下文信息，线程切换的代价要比进程切换小得多。
4. 进程间通信的代价比线程通信大。由于进程间通信需要经过内核参与，因此需要进行频繁的上下文切换和数据拷贝。

总的来说，线程和进程都是操作系统的重要组成部分，各自有着不同的应用场景。在设计程序时，需要根据实际需求选择合适的线程和进程模型。
### 22. 多线程访问同一资源时的操作
在多线程访问同一资源时，可能会出现数据竞争和死锁等问题，因此需要采用以下操作来确保线程安全：
1. 互斥锁（Mutex）：互斥锁用于保护临界区，在**临界区访问共享资源之前先获取互斥锁，访问完成之后再释放互斥锁**。互斥锁的机制可以**确保同一时刻只有一个线程访问临界区**，可以避免数据竞争的问题。
2. 读写锁（RWLock）：读写锁在互斥锁的基础上**增加了读写分离**的功能。读写锁允许多个线程**同时读取共享资源，而只有写线程需要获得锁**，以保证写的操作是串行进行的。
3. 条件变量（Condition Variable）：条件变量通常与互斥锁一起使用，在特定条件下等待或唤醒某些线程。线程可以等待某一条件的发生，而不需要消耗 CPU 资源；同时其他线程可以唤醒等待某一条件的线程。
4. 原子操作（Atomic）：原子操作可以实现一些简单的线程同步机制，例如原子加、减、比较交换等。由于原子操作不需要获取锁，因此性能较好，但是只能用于简单的操作。
5. 信号量（Semaphore）：信号量是用于控制对共享资源的访问的一种机制，主要用于进程间通信（IPC）。可以将信号量看作是受保护的计数器，线程可以通过信号量的值来判断共享资源的状态，从而进行相应的操作。

综上所述，多线程访问同一资源时，可以采用上述操作来确保线程安全。不同的操作机制具有各自的特点和适用场景，开发者需要根据实际情况选择合适的机制。
### 23. 设计模式
设计模式是解决软件设计中常见问题的经验总结，可以提供一些通用的、可重用的解决方案。目前比较常见的设计模式如下：
1. 单例模式：确保一个类只有一个实例，并提供一个全局访问点。
2. 工厂模式：通过工厂方法创建实例对象，将对象的创建和使用进行分离，从而增强了灵活性和可扩展性。
3. 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖它的对象都将得到通知，并自动刷新。
4. 策略模式：定义一系列算法，并将它们各自封装起来，它们之间可以互相替换使用，从而使得算法可以独立于使用它的客户端而变化。
5. 装饰器模式：动态地给一个对象增加一些额外的行为，装饰器提供了一种比继承更加灵活的扩展方案。
6. 迭代器模式：提供一种方法来访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。
7. 原型模式：通过复制现有的对象来创建新的对象，具有一定的效率优势。
8. 适配器模式：将一个类的接口转换成客户期望的另一个接口，使原本不兼容的类可以协同工作。

### 24. 渲染管线
1. **顶点处理**（Vertex Processing）：将3D场景中的顶点按照一定的规则进行处理，包括变换、光照等操作，最终产生屏幕空间坐标。

	在这个阶段，会对每个顶点进行变换操作。这一步通常包括顶点变换、光照计算、纹理坐标计算等。顶点变换包括将顶点从模型空间（Object Space）转换到世界空间（World Space）、从世界空间（World Space）到相机空间（View Space）、从相机空间（View Space）到裁剪空间（Clip Space）。在这个过程中，通常会使用投影矩阵进行透视和平行投影，以将物体从三维的场景坐标转换成二维的屏幕坐标。光照计算会考虑场景中的光源，计算每个顶点的光照强度和颜色。纹理坐标计算会将纹理映射到顶点上，为后面的纹理采样做准备。
	
2. **图元装配**（Primitive Assembly）：将顶点连接起来形成图元，如点、线、三角形等。

	这个阶段将顶点按照设定的方式连接起来，形成基本的图元，如点、线、三角形等。图元装配阶段的主要任务是确定每个图元的形状和大小，为后续光栅化进行准备。
	
3. **光栅化**（Rasterization）：将图元内部的像素化，生成一个个像素点，并进行逐个处理。
	
	在这个阶段，会将每个图元转换成屏幕上的像素点，生成一张图像。这个阶段的核心是对每个图元进行像素化，即将图元内部的点转换为像素点，并为像素点计算颜色。光栅化流程包括判断像素是否在图元内、计算像素覆盖面积和深度值、对像素进行插值等操作。
	
4. **片元处理**（Fragment Processing）：对每个像素进行处理，包括采样纹理、计算光照等操作。
	
	在这个阶段，会对每个像素进行处理。这个阶段的主要任务是对每个像素进行灯光计算和纹理采样。灯光计算包括计算每个像素点的颜色、亮度、透明度等。纹理采样则是将图元的纹理贴到屏幕上的像素点上。这个过程通常会使用一些复杂的算法，如多重采样、反锯齿等。
	
5. **输出合成**（Output Merger）：将处理后的像素输出到帧缓冲区，并进行深度测试、混合等操作。
	
	在这个阶段，会将最终的像素合成器对每个像素进行处理，并将像素输出到帧缓冲区。输出合成阶段的主要任务是深度测试、混合、色彩空间转换、色彩调整等。
    
在现代渲染管线中，还有一些新的技术被引入，例如着色器程序、延迟渲染、前向渲染、后处理等，这些技术可以在各个阶段进行优化和增强渲染效果。理解和掌握渲染管线对于进行游戏开发和图形编程非常重要。


### 25. UE里的动画蓝图
动画蓝图是UE中一个用于创建和管理动画的可视化系统，类似于蓝图系统，但**主要用于控制骨骼动画**。动画蓝图允许开发人员使用蓝图节点的方式创建和编辑骨骼动画蓝图。

在UE中，动画蓝图通常由两部分组成：动画蓝图节点编辑器和动画蓝图实例。动画蓝图节点编辑器用于在节点上编写蓝图，可以使用不同的节点类型，例如变量、计算、控制流等。这允许开发人员使用图形化的方式来控制骨骼动画，而不需要编写代码来定义动画逻辑。

在编辑完动画蓝图后，需要创建一个动画蓝图实例，它将使用所选的骨架网格，将蓝图转换为可执行的动画逻辑。动画蓝图实例与游戏对象相关联，可以在游戏运行时对其进行操纵和观察。

动画蓝图在UE中非常重要，它可以用于实现复杂的运动模式和逻辑，并可以与蓝图系统和其他UE功能进行交互。它还可以用于创建角色的动作控制器，如腿部动画、臂部动画等，使游戏看起来更加生动自然。

### 26. 游戏里的AI
游戏中的AI（Artificial Intelligence，人工智能）一般通过以下技术来实现：
1. **状态机**（State Machine）：状态机是一种常见的AI实现方式，它将AI行为分成不同的状态，并使用转移条件来控制状态之间的切换。例如，在一个动作游戏中，一个敌人角色的状态可能包括Idle、Walk、Attack、Hurt、Die等。状态机通过编写状态和转移条件的逻辑，实现AI的运动、攻击和反应等行为。
2. **行为树**（Behavior Tree）：行为树是一种层次化的AI设计模式，基于一组决策节点和执行节点。决策节点用于评估当前情况，决定哪些执行节点可以运行。执行节点则控制角色的行为，如移动、攻击、躲避等。行为树通常比状态机更灵活和可扩展，但需要更多的编程和设计能力。
3. **基于规则的AI**（Rule-based AI）：基于规则的AI根据一组预定义的规则和条件，运行预设置的行为。例如，在一个策略游戏中，AI可以根据资源和军队数量控制建筑建造、单位组织和战斗指挥等行为。这种AI设计通常比较简单，但不够灵活，无法适应未来可能的变化和不确定性。
4. **机器学习**（Machine Learning）：机器学习是一种AI设计方法，它使用算法对数据进行训练，从而让机器具备主动学习和适应的能力。在游戏中，机器学习可以用于创建智能的NPC角色、实现自学习的对战AI等。但是，机器学习的实现通常需要大量的数据和计算资源，对游戏性能有极高的要求。

总之，不同类型的游戏需要不同的AI设计方法，开发者需要根据游戏类型和要求选择适合的AI技术，并不断优化和改进实现。

### 27. 行为树的重要节点
行为树（Behavior Tree）是一种用于实现游戏AI的常见技术，其中最重要的节点包括：
1. **选择节点**（Selector Node）：选择节点是行为树的根节点，它控制其他节点的执行，并根据先决条件选择执行哪个子节点。如果当前子节点不能运行，则选择节点会按照先后顺序依次检查其他子节点。通常用于实现复杂的NPC行为。
2. **序列节点**（Sequence Node）：序列节点是行为树中的另一个常见节点，用于顺序执行一系列子节点。当一个子节点返回成功时，序列节点会继续执行后续节点，直到所有子节点都成功或者失败。通常用于实现NPC的动作序列。
3. **行动节点**（Action Node）：行动节点是行为树中的叶子节点，用于完成具体的行为操作，如移动、攻击、开门等。当一个行动节点运行时，它会执行相应的动作，并返回成功或失败状态。
4. **条件节点**（Condition Node）：条件节点用于检查当前游戏状态，以决定是否执行下一步操作。当条件满足时，条件节点会返回成功状态，并导致选择节点或序列节点执行下一个子节点。如果条件不满足，则条件节点返回失败状态，并不执行下一个子节点。
5. **循环节点**（Loop Node）：循环节点用于周期性执行子节点，直到某个特定条件满足为止。循环节点通常用于实现重复性动作，如保卫某个区域、持续攻击敌人等。

以上是行为树中比较常见和重要的节点，它们可以通过组合和嵌套方式形成复杂的AI行为逻辑，用于实现不同类型的游戏NPC行为。

### 28. 射击游戏里子弹发射、击中敌人扣血等机制
在射击游戏中，子弹发射和敌人扣血的实现一般需要以下步骤：
1. 创建子弹和敌人实体：首先需要创建子弹和敌人的游戏实体，其中子弹通常是一个Prefab，敌人则是一个角色模型。
2. 设定子弹物理属性：指定子弹的物理属性，如速度、飞行距离、攻击力等。可以通过刚体组件和碰撞体组件实现子弹的运动和碰撞。
3. 计算子弹运动轨迹：指定子弹的初始位置和方向，然后在每一帧中计算子弹的轨迹，将其移动到目标位置，实现子弹的运动。
4. 检测子弹碰撞：在每一帧中，需要检测子弹与敌人是否发生碰撞，可以通过碰撞检测器实现。如果子弹与敌人发生碰撞，则触发子弹命中敌人的效果。
5. 减少敌人生命值：当子弹击中敌人时，需要减少敌人的生命值，可以通过修改敌人生命值变量实现。如果敌人生命值降至0，则触发敌人死亡效果，可以播放死亡动画、播放音效或者移除敌人实体。
6. 处理子弹和敌人的销毁：当子弹击中敌人或者超出射程后，需要销毁子弹实体。当敌人死亡后，需要关闭敌人的渲染和碰撞体，防止在游戏中再次出现。

以上是射击游戏中子弹发射、命中敌人、敌人扣血的基本实现流程，可以根据实际游戏需求进行优化和完善。

### 29. 获取子弹和敌人碰撞这一事件
在游戏中，可以通过添加碰撞器组件来处理子弹和敌人的碰撞事件。
对于子弹和敌人的碰撞，一般有两种方法来检测：
1. **物理引擎碰撞检测**：可以通过给子弹和敌人都添加刚体组件，然后让物理引擎来处理碰撞检测。当子弹和敌人碰撞时，就会调用OnCollisionEnter方法，可以在这个方法中处理碰撞事件，比如减少敌人的生命值。
2. **触发器碰撞检测**：可以给子弹添加一个触发器（Trigger），然后让敌人作为触发器的响应对象。当子弹与敌人发生碰撞时，就会调用OnTriggerEnter方法，可以在这个方法中处理碰撞事件，比如减少敌人的生命值。

无论采用哪种方法，都需要在游戏中为子弹和敌人添加对应的碰撞检测组件，并在相应的方法中实现具体的碰撞事件处理逻辑。根据实际需求，还可以添加碰撞事件的触发条件和回调函数，实现更加灵活的碰撞处理。

### 30. 碰撞的底层实现吗?
碰撞的底层实现主要是基于物理引擎。物理引擎主要负责模拟物理世界中的各种现象，如力、运动、碰撞等，确保游戏中各个物体的运动和交互具有真实性和可预测性。

常见的物理引擎有Unity自带的PhysX、Bullet、Havoc等。这些引擎都是基于刚体的物理模拟，刚体是一种具有质量、大小、形状等属性的物理实体，所有与之交互的物体都需要具有刚体组件。

在每一帧中，物理引擎都会对所有的刚体做如下操作：
1. **重力影响**：物理引擎首先会计算物体所受到的重力加速度，然后根据速度和加速度来更新物体位置和速度。
2. **碰撞检测**：物理引擎会对所有的刚体进行碰撞检测，检测到碰撞后会计算碰撞的力量和方向，并更新物体位置和速度。
3. **碰撞解决**：物理引擎会根据碰撞信息来解决碰撞，如反弹、滑动等。通常还会考虑物体的摩擦力、弹性等因素，使得物体的运动和交互更加真实。

物理引擎的底层实现十分复杂，需要涉及到数学、物理、计算机图形学等多个领域的知识。对于游戏开发者而言，只需要掌握物理引擎的基本使用和常用效果即可，不必深入了解其底层实现。

### 31. UE的反射机制
Unreal Engine（UE）的反射机制是其内置的一种基础机制，用于在运行时获取和操作对象的类型、属性、方法等信息。反射机制可以在**不知道对象实际类型的情况下访问其属性和方法，提高代码的灵活性和可重用性**。

UE的反射机制基于C++语言，通过动态类型（Dynamic Type）实现。在编写UE游戏时，我们可以使用反射机制来处理以下一些场景：
1. 在运行时检测对象的类型，以便确定其属性和方法该如何访问。
2. 动态创建对象和调用对象的方法。
3. 构建自定义编辑器UI，以在编辑时访问对象的属性和方法。

UE的反射机制主要包括以下几个组成部分：
1. UClass：表示一个类，其包含了该类的基本信息，如名称、父类、默认对象等，也可以用来动态创建对象、访问属性和方法等。
2. UObject：表示一个对象，其包含了该对象的实例信息，如基本属性、方法等。
3. UProperty：表示一个属性，其包含了该属性的类型、名称、读写权限等，可以用来访问对象的属性。
4. UFunction：表示一个方法，其包含了方法的名称、返回值类型、参数等，可以用来调用对象的方法。

通过UE的反射机制，我们可以在运行时动态获取对象的类型信息，并且根据对象的类型信息来访问和操作其属性和方法，可以大大简化代码量，提高开发效率。同时，UE的反射机制也是其可视化编辑器和蓝图系统的基础，使得开发者可以通过可视化的方式构建游戏逻辑和交互，大大提高了游戏开发的效率和质量。

### 32. 对引擎更多的了解
引擎是指一类专门用于游戏或应用程序开发的软件框架，提供了一系列工具和库，以便开发人员能够快速、高效地开发出更好的游戏或应用程序。

在游戏开发方面，引擎的主要作用就是提供游戏开发所需的各种基础设施，如图形渲染、物理模拟、碰撞检测、音效系统等，使得开发人员能够更加专注于游戏本身的逻辑和玩法开发，而不必花费大量的时间和精力去编写这些基础设施。

除此之外，引擎还提供了一些额外的功能，如跨平台支持、可视化编辑器、脚本语言支持、网络编程等，以便开发人员能够开发出适应不同平台、不同需求的游戏和应用程序。

目前，市面上较为常见的游戏引擎包括Unity、Unreal Engine、Cocos2d、CryEngine等。这些引擎都具有各自独特的特点和优势，开发人员可以根据自身的需求和技能水平选择合适的引擎进行开发。

总体而言，引擎是游戏开发中不可或缺的基础设施，能够为开发者提供重要的工具和库，使得游戏开发更加高效、便捷、灵活。

Unreal Engine（UE）的引擎实现主要包括以下几个方面：

1. 渲染引擎：UE的渲染引擎使用了最新的渲染技术，包括DirectX 12和Vulkan等，同时也支持OpenGL和Metal。UE的渲染引擎可以定制化，开发者可以根据自己的需求和平台特性来进行修改，以达到更好的游戏性能和视觉效果。
2. 物理引擎：UE的物理引擎基于NVIDIA的PhysX引擎进行开发，支持实时碰撞检测、重力模拟、角色动画等功能。物理引擎支持多种材质，如金属、木材、石材等，并且可以扩展新的材质。
3. 音效引擎：UE的音效引擎支持3D音效、接口音效和音频解码等多项功能。音效引擎在PC和主机等平台上都提供了高质量、低延时的音效效果。
4. 关卡编辑器：UE的关卡编辑器是一款全面的可视化编辑器，可用于创建游戏关卡。通过该编辑器，开发者可以轻松创建具有复杂地形、大量动态实体和粒子效果的游戏关卡。
5. 蓝图系统：UE的蓝图系统是基于节点的可视化编程框架，可用于设计和创建游戏逻辑。通过该系统，开发者可以在不编写任何代码的情况下创建复杂的游戏逻辑，包括人物AI、战斗系统、交互操作等。
6. 网络引擎：UE的网络引擎可以在游戏中处理多种网络功能，如多人游戏、匹配模式、统计和实时通信等。其网络架构支持客户端/服务器模式和点对点模式，可以使用TCP和UDP协议进行通信。
7. 脚本语言：UE支持多种脚本语言，包括C++和Blueprint蓝图，还支持Python、JavaScript等语言的扩展。脚本语言可用于快速创建游戏逻辑和工具，增强了UE的灵活性。

Unity的引擎实现主要包括以下几个方面：
1. 渲染引擎：Unity的渲染引擎支持多种图形API，如DirectX、OpenGL、Metal等。同时还支持着色器和屏幕空间反射等渲染技术，以及全局光照和实时阴影等功能。
2. 物理引擎：Unity的物理引擎基于NVIDIA的PhysX引擎进行开发，支持碰撞检测、重力模拟、角色动画等功能，同时还支持柔体动力学技术。
3. 音效引擎：Unity的音效引擎支持3D音效、复杂混音、音效距离与衰减等功能，同时还支持音频剪辑和实时变换等。
4. 关卡编辑器：Unity的关卡编辑器提供了一个可视化编辑器界面，能够支持开发者创建地形和布置场景。
5. 脚本语言：Unity的主要脚本语言是C#，但也支持JavaScript和Boo等语言。C#语言的运行速度较快，而且可以嵌入其他.NET技术。
6. 网络引擎：Unity的网络引擎支持多种网络功能，包括多人游戏、服务器托管和实时通信等，可以使用TCP和UDP协议进行通信。同时，Unity还支持第三方框架和云服务。

与UE相比，Unity的优点在于其较为轻量和易用，且开发效率高。Unity采用了Component-Entity架构，可组件化和模块化开发，能够快速迭代游戏，同时还支持多平台发布和一键迭代。在移动游戏领域，Unity已经成为了主流的开发引擎。

而UE则以其强大的渲染和物理引擎、可自定义性和精度等方面脱颖而出，在3A大型游戏领域具有优势。UE拥有更强大的关卡编辑器、蓝图系统以及更高质量的视觉效果，同时对物理模拟支持更加全面，具有更好的游戏性能和效果。
 
应该还有一些其他的，但当时忘录音了，记不起来了
反问:
简单问了下腾讯现在用的哪种引擎比较多问了下面试官项目组的情况，还问了去了以后是否要学习unity


![[Pasted image 20240411170454.png]]
# 二面
面了大概45min左右
自我介绍

1. 比赛经历(过程方面，问到了小组人数，怎么组到的队，赛赛事流程等等)
### 2. 给了一些需求，问在不使用引擎的情况下有什么思路去实现这些需求(这算是情景类问题吗?感觉没答好，整个这一块似乎总是没和面试官对上脑电波)
在不使用引擎的情况下，我们可以根据给定的需求使用编程语言和计算机图形学基础知识来实现这些需求。下面简单列举一些思路：
1. 渲染：使用计算机图形学基础知识实现基础的光栅化渲染器，可以实现简单的2D或3D渲染，包括三角形绘制、光源计算、材质贴图、深度测试等功能。
2. 物理：自行编写物理引擎，包括碰撞检测、物理运动计算、重力模拟、角色动画等。
3. 音效：使用音频编程库或模拟算法实现音频解码与播放，以及基础的音效特效等功能。
4. 关卡编辑器：使用编辑器GUI和文件读写操作，实现关卡数据的可视化编辑和存储。
5. 脚本语言：选择一种编程语言，编写脚本实现游戏逻辑，如人物AI、交互操作、游戏状态管理等。
6. 网络引擎：使用网络编程知识实现基本的客户端/服务器通信和数据传输。

当然，以上只是非引擎实现游戏需求的一些思路，具体实现方案需要根据需求复杂度、技术难度和开发周期等因素进行具体分析和评估。

3. 问第一个比赛作品里自己遇到的难点有哪些
### 4. 个人感觉从团队合作角度来看使用蓝图和C++哪个方便?
从团队合作的角度来看，使用蓝图相对于C++开发来说更加方便。以下是几个原因：
1. 相对容易学习和理解：相对于纯代码开发，蓝图更加直观和易于学习。蓝图提供了一种可视化的编程方式，具体实现通过拖拽和连线实现，适合不擅长编写代码的美术和策划人员参与制作。
2. 减少代码重构和调试：使用蓝图可以减少因为模块修改导致的代码重构和调试工作。对于传统方式使用C++来说，每次改变功能性需求都可能需要改变很多代码，开发者无法轻松找到依赖关系，容易造成版仓库冲突等问题。
3. 提高开发效率：蓝图能更快速地搭建原型，能给游戏开发团队带来更高的开发效率，也能指导美术和策划人员更快地理解和跟进开发进度。
4. 更易于代码管理：蓝图的目的是让蓝图脚本和C++代码更易于管理，尤其是针对团队中并非所有人员都擅长编写C++的情况下。

当然，使用蓝图开发可能会导致游戏逻辑变得不直观，难以调试，同时也可能会降低游戏的运行效率。因此，在选择开发方式时，应该按照团队成员的技术能力、项目需求和开发进度等因素做出合理选择。

5. 介绍一下第二个比赛作品
### 6. 寻路了解哪些算法?(这回准备了，答了A*)
寻路是指从起始点到目的地的路径规划，因此需要考虑路径的长度、形状、通畅度等因素。下面是一些常用的路径规划算法：

1. `A*`算法：是一种启发式搜索算法，可以找到从起点到终点的最短路径。由于它具有较好的效率和准确性，因此在游戏开发中使用较多。
2. Dijkstra算法：主要用于解决带权图的单源最短路径问题。它通过维护当前已访问的节点的最短路径来更新其他节点的最短路径，直到所有节点已访问。
3. Bellman-Ford算法：也是用于带权有向图的单源最短路径问题，但相对于Dijkstra算法，Bellman-Ford算法能够处理存在负权边的情况。
4. Floyd算法：适合处理小规模图的最短路径问题，能计算任意两点间的最短路径。它的思路是通过动态规划来计算任意两点之间的最短路径。
5. 可见图算法：将地图划分成为一系列的小网格，对于其中的每个网格，标记它的可达或不可达状态。然后，将这些网格合并为一个可见图，使用`A*`算法等其他路径规划算法在该图上进行搜索，以得出从起点到终点的最短路径。 

在实际开发中，尤其是在实时游戏开发中，通常使用基于网格图或搜索树的寻路算法，如著名的NavMesh技术等。

### 7. 详细讲一下`A*`原理
`A*`算法是一种启发式搜索算法，用于快速找到从起点到终点的最短路径。它综合了广度优先搜索和贪心算法的思想，并利用了估价函数来评估每个节点的优先级，从而使搜索效率更高。

算法步骤：
1. 将起始点设置为起点，并将起始点加入Open列表（开放列表，存放未处理的节点）中，设置起始点的路径长度为0。
2. 从Open列表中选择一个F值（F = G + H，其中G为起点到当前节点的路径长度，H为当前节点到终点的估算路径长度，如曼哈顿距离等）最小的节点作为当前节点，将其从Open列表中移除，并将其加入Closed列表（关闭列表，存放处理完毕的节点）中。
3. 对于当前节点周围的每一个可到达的节点，如果该节点已经在Closed列表中，则略过下面所有步骤；如果该节点不在Open列表中，则将该节点加入Open列表，并计算该节点到起始点的路径长度G和该节点到终点的路径长度H，最后将该节点的父节点设置为当前节点；如果该节点在Open列表中，需要根据新计算的G值更新原来的节点信息，选择最优路径。
4. 重复上述步骤，直到终点加入了Closed列表中，找到了从起点到终点的最短路径；或者Open列表为空，即不存在可遍历的节点，则表示无法到达终点。

值得注意的是，估价函数H的选择能够显著影响算法的效率和准确性。如果H的值越准确，`A*`算法需要搜索的节点就会越少，算法效率也会越高。因此，在实际应用中，需要根据场景情况合理选择估价函数。

`A*`算法是一种高效的寻路算法，常用于游戏开发和人工智能领域。与其他路径规划算法相比，`A*`算法不仅能够找到最短路径，而且能够在搜索过程中剪枝，提高搜索效率。

### 8. 你觉得`A*`适用于哪种寻路?(答曰地图容易抽象成一个网格的游戏)
`A*`算法是一种高效的寻路算法，它适用于以下类型的寻路场景：
1. 求解起点到终点最短路径问题。`A*`算法是一种启发式算法，它综合了广度优先搜索和贪心算法的思想，能够快速找到起点到终点之间的最短路径。因此，在需要寻找最短路径的场景中，`A*`算法是一种十分适合的选择。
2. 搜索空间较大、分支较多的场景。`A*`算法通过估计节点的代价函数和启发式函数，将搜索空间限制在可能最优的路径上，而不是搜索所有可能的路径，从而减少搜索的数量。因此，在搜索空间较大、分支较多、复杂度较高的场景中，`A*`算法表现较好。
3. 需要搜索多个终点的场景。`A*`算法可以通过将多个终点加入自己的队列中，而在不同的点上使用不同的启发式函数， 来准确地寻找一个环绕所有目标的路径。因此，对于需要同时搜索多个目标的场景，`A*`算法可作为一种高效的选择。

总之，`A*`算法适用于需要求解起点到终点的最短路径，搜索空间较大、分支较多、复杂度较高、需要搜索多个终点等场景，是一种十分高效的寻路算法。

### 9. 那如果想MMORPG类型的游戏你觉得寻路要怎么做?
对于MMORPG类型的游戏，寻路是一个重要的问题。因为在游戏中，玩家和游戏NPC需要频繁地进行寻路，并找到最短的路径。这个寻路过程需要在游戏中实时计算完成，因此需要考虑寻路的速度和效率。

针对MMORPG类型的游戏，我们可以采用以下方案来实现寻路：
1. 使用A_算法作为寻路算法。`A*`算法是一种非常高效的寻路算法，能够找到最短路径，对于在游戏中寻找最短路径的需求非常适合。在使用`A*`算法时，可以通过合理的启发式函数来减小搜索空间，提高寻路效率。
2. 在使用`A*`算法时，可以采用两种方式来提高寻路效率。第一种是采用预处理数据结构（如网格、KD-Tree等）来加速A_算法中的路径搜索。第二种是使用分治法的思想，将地图划分成多个小区域，然后分别寻路，最后将所有小区域的路径拼接起来，这样可以提高`A*`算法的搜索速度。
3. 可以使用动态寻路算法来实现寻路功能。动态寻路算法是一种基于分层图的寻路算法，该算法将地图分成多个层次，每个层次由多个小区域组成，每个小区域都有一个代表点。在寻路时，通过每个代表点之间的连线并进行搜索，最终得到所有的路径。使用动态寻路算法，可以避免动态地维护大规模的寻路数据，从而提高寻路效率。
4. 可以使用`A*`算法和预处理数据结构的组合算法来实现寻路功能。该算法将地图划分成多个小区域，并将每个小区域预先计算得到一些关键数据。在寻路时，使用`A*`算法根据这些数据进行寻路，从而减少寻路过程中的计算量。

综上，对于MMORPG类型的游戏，寻路算法需要考虑速度和效率的问题，可以使用`A*`算法、预处理数据结构、动态寻路算法等方式来实现寻路功能，同时根据游戏特性和需求，选择合适的算法来实现最佳的寻路效果。

### 10. 怎么了解的UE里的AI模块呢?
UE（Unreal Engine）的AI模块是一套完整的人工智能解决方案，包括了AI控制器、行为树、感知系统、导航系统、AI角色蓝图等等。以下是关于UE里的AI模块的详细说明：
1. AI控制器：AI控制器是UE中最基础、最重要的部分，它是所有非玩家角色（Non-Player Character，NPC）的主要控制器。使用AI控制器可以对NPC进行操作，包括让NPC移动、进行攻击、接受玩家的输入等等。
2. 行为树（Behavior Tree）：行为树是一种用于AI逻辑的编程模型，可以实现像决策树一样的逻辑结构。行为树通过递归的方式，对所有“行为”进行优先级排序，最终通过顶层节点提供的结果来进行操作。在UE中，可以通过视觉化建模工具“BehaviorTree Editor”来创建自定义的行为树。
3. 感知系统（Perception system）：感知系统是UE上最重要的AI技术之一，它可以让NPC感知周围的物体、声音和事件等。感知系统使用方便的视觉化工具和API来管理和实现NPC的感知行为。
4. 导航系统（Navigation system）：导航系统是UE内置的一套用于NPC路径规划和移动的系统。导航系统提供了一组易于使用的API，用于在游戏中实现自动化的路径生成、避障和行走等功能。
5. AI角色蓝图（AI Character Blueprints）：UE的AI角色蓝图是一套用于创建和配置NPC的工具，包括了角色的基础属性、外观、行为树、AI控制器和感知系统等。

总之，在UE中，AI模块提供了非常完整、易于使用的人工智能解决方案。通过结合这一套解决方案，可以很容易地创建自己的非玩家角色，并使它们在游戏中实现各种行为和交互。

### 11. 为什么用行为树制作AI而没用状态机呢?
在开发游戏的过程中，使用行为树或状态机来制作AI都是可行的。但是，为什么在UE中使用行为树而不是状态机呢？原因主要有以下几点：

1. 行为树更易于理解和可视化：相比状态机，行为树更易于理解和可视化。在行为树中，要做的工作就是构建目标行为的树形层级结构，并将每个行为根据其优先级进行排序。这样一来，游戏设计师和程序员可以更容易地理解和调整AI的行为。而在状态机中，代码包含了很多条件判断和状态转换的逻辑，更加复杂。
2. 行为树支持更高级的逻辑：行为树可以非常简单地实现高级逻辑，例如动态选择子树、中止行为、并行执行、随机选择等等。这使得行为树在复杂场景下具有更好的可扩展性和灵活性。
3. UE内置的行为树编辑器更加强大：UE内置的行为树编辑器可以让游戏设计师更加轻松地创建和管理行为树。相比之下，状态机的编辑器需要程序员更多的编码工作。

总之，行为树通过其可视化、可扩展和灵活的特点成为了UE中实现AI的首选方法。但如果开发人员认为状态机更适合其中某些特定方面的任务，他们也可以使用状态机来实现AI。
12. 问下一个项目(FPS)
### 13. 不同枪械动作切换的思路?
不同枪械动作切换的思路可以分为以下几个步骤：
1. 确定动作：首先，需要确定每种枪械可以进行哪些动作，例如开火、瞄准、换弹等等。此外，还要确定每个动作需要的时间、动画、音效等等。
2. 实现状态机：将每种枪械的状态抽象成一个状态机，根据玩家的输入和当前状态更新状态机。例如，当玩家按下开火键时，如果当前状态是“待机”状态，则切换到“开火”状态。每种状态必须负责自己的动画、音效以及控制枪械相关的物理行为。
3. 切换状态时进行动作：当切换到另一个状态时，需要进行动作切换。此时可以使用动画融合技术，将前一个状态的动画融合到下一个状态的动画上，使得动作转换更加自然。
4. 确定动作结束时机：每种动作都需要有一个结束时机，在此时机到来时，状态机会自动切换到下一个状态。例如，当枪械动画播放完成，并且子弹被换完时，状态机会自动从“换弹”状态切换到“待机”状态。
5. 调试和优化：在开发过程中，需要不断地测试和调试枪械动作切换的逻辑，确保枪械可以流畅地进行各种动作切换。同时，需要考虑如何优化动画、音效和状态机，提高游戏性能和用户体验。

总之，枪械动作切换需要通过状态机实现，由状态机控制枪械的各种状态，根据玩家的输入和当前状态进行状态切换，并在状态切换时进行动画、音效等各种操作。通过不断的调试和优化，可以实现更加流畅和真实感的枪械动作切换。
### 14. 发射物?弹道?
游戏中发射物和弹道的实现可以根据具体游戏的需求和玩法不同而有所差异，但一般的实现思路如下：
1. 确定射击起点和射击方向：在发射物或弹道的开始位置，例如玩家手中的枪械，需要确定射击方向和弹道起始位置。
2. 计算弹道轨迹：根据射击方向和起始位置，以及子弹的初始速度和重力等因素，计算弹道轨迹。通常使用物理引擎或数值计算来实现弹道的模拟。
3. 跟踪弹道：一旦发射的子弹或弹道被创建，就需要让其在游戏中跟踪弹道轨迹，并产生相应的物理效果。这时需要使用可视化工具或代码手动进行跟踪，同时实现子弹的发射特效和声音效果。
4. 碰撞检测：在游戏中，需要对发射物和弹道进行碰撞检测，判断它们是否与其他游戏元素碰撞。如果击中其他游戏元素，则需要触发相应的反馈效果，例如造成伤害、爆炸等。
5. 调试和优化：在实现发射物和弹道的过程中，可能会出现诸如物理表现不真实、跟踪不准确等问题，需要使用调试工具和性能分析工具进行问题排查和优化。

总之，实现游戏中的发射物和弹道需要通过物理引擎或自行编写数值计算代码来模拟弹道的轨迹，同时需要进行碰撞检测、物理特效和声音剪辑等操作。只有在实现的过程中注重细节和优化，才能实现更加真实、有趣的游戏射击体验。

### 15. 火箭弹之类的发射物移动过程中和服务器的通信?
在游戏中，火箭弹、导弹等远程发射武器的移动过程中需要与服务器进行通信。此时，常采用客户端/服务器架构，客户端控制着发射物的运动轨迹和状态，而服务器负责监管、验证和同步各个客户端的状态，确保游戏的公平性和一致性。

具体实现流程如下：
1. 客户端发射火箭弹，发送发射命令给服务器。
2. 服务器根据玩家输入、当前状态和环境信息来计算火箭弹的初始位置、速度和轨迹，并将火箭弹的信息返回客户端。
3. 客户端用计算好的初始位置和速度来更新火箭弹的位置，同时监视火箭弹与场景中其他物品的碰撞。如果火箭弹撞到了目标，则立即向服务器发送目标击中命令。
4. 服务器验证目标是否合法以及火箭弹是否确实撞上目标，然后发送相应的伤害值给客户端。
5. 客户端根据火箭弹的状态和伤害值来更新游戏画面和状态。

在这个过程中，客户端和服务器之间需要进行频繁的通信和数据传输，要确保通信的实时性和稳定性，避免出现延迟、丢包或冲突。同时，还需要保证通信内容的安全和防止作弊行为。因此，需要使用安全的通讯协议和作弊检测机制来实现通信。

### 16. FPS摄像机位置?
FPS游戏中，摄像机通常采用第一人称视角，即玩家所看到的视野就是摄像机所在的位置和方向。因此，FPS摄像机的位置通常设置为玩家头部的位置，并随着玩家的移动而移动，以实现玩家的观察视角跟随。

具体来说，FPS摄像机的位置可以通过以下方式实现：
1. 将摄像机的位置设置为玩家头部的位置：在游戏中，可以通过获取玩家模型的头部位置和朝向来确定摄像机的位置和方向。
2. 实现摄像机随着玩家移动而移动：在游戏中，玩家角色通常通过键盘或手柄控制，根据玩家的输入移动后，摄像机的位置和方向也需要相应地随着移动。因此，通常使用相机跟随算法来实现摄像机位置的随动跟随。
3. 实现摄像机的视野控制：FPS游戏中，视野的控制常常通过鼠标和键盘来实现，玩家可以通过移动鼠标来改变视野的方向。因此，在实现FPS摄像机时，需要根据玩家输入来实时更新摄像机的朝向和方向。
4. 实现视角抖动：为更加真实地模拟玩家的视角，可以增加视角抖动效果，让玩家感受到更真实的环境和情境，例如运动时的头部抖动、强行撞击等等。

### 17. 瞄准效果怎么做的?
在FPS游戏中，瞄准效果可以通过修改摄像机的位置和视野角度来实现。常见的瞄准效果有两种：缩放式瞄准和移动式瞄准。

可行的实现步骤如下：
1. 设置缩放比例或偏移量： 模拟瞄准时，需要调整摄像机的位置和视野范围。对于缩放式瞄准，可设置摄像机的缩放比例或透视视野来实现，使得玩家能够更好地看到目标；对于移动式瞄准，需要对摄像机进行平移，使得目标能够更好地置中于屏幕内。
2. 触发时机： 触发瞄准模式的时机通常是玩家按下右键或者其他在游戏中设定的快捷键。
3. 实现瞄准效果：通过修改摄像机的位置和视野范围，实现瞄准效果。
4. 恢复正常状态：当玩家松开右键或快捷键，要恢复摄像机的正常状态，以便玩家能够更好地进行游戏。

需要注意的是，瞄准效果的实现要注意玩家体验和平衡性，不能强制玩家进行瞄准或瞄准过于简单，同时也不能过于复杂或过于困难。为了达到最佳的游戏体验，需要在游戏中进行反复测试和细节调整。

### 18. 无缝大地图的实现思路?
实现无缝大地图的关键在于如何让地图随着玩家的移动而无缝切换，同时保证不会出现可见的地图拼接。
以下是无缝大地图的实现思路：
1. 地图的分块：将整个大地图划分成多个小块，每个小块大小需要根据实际情况来确定。对于三维世界，通常将小块设置为立方体或其他规则形状。
2. 坐标系统的设计：设计一个坐标系统来描述玩家和小块的位置，同时保证分块后的每个块在坐标系统中的位置唯一。一般来说，使用二维直角坐标系或三维直角坐标系来实现。
3. 地图的预加载：在玩家移动到离当前小块较远的位置时，需要预加载一定范围内的小块，以减少切换时间和延迟。
4. 无缝切换：在玩家接近当前小块的边界时，检测其所处坐标是否超出当前小块，如果是，就根据玩家位置和当前小块的位置计算出需要切换到的新小块。然后，将玩家位置从当前小块的坐标系转换到新小块的坐标系，并从新小块的预加载列表中预加载相邻的小块。这个过程需要在无缝实现的同时，确保不会出现可视的拼接缝隙。
5. 地图连接点的设计：确保每个小块在相邻小块接口处的地形、建筑等物体的位置一致。这可以通过精细的地图设计来实现，以确保小块之间的过渡自然流畅。

需要注意的是，无缝大地图的实现对计算机的性能要求较高，需要考虑适当的优化，尤其是在预加载、切换和连接点的设计方面，需要仔细考虑，以确保玩家能够流畅地体验游戏。

### 19. 看到我玩过剑与魔法题材，就技能系统相关问了一系列问题
剑与魔法题材的技能系统，通常需要具备多样化的特点，既能够满足玩家的需求，也需要考虑平衡性和游戏体验。
以下是实现剑与魔法题材的技能系统的思路：
1. 技能设计：设计多种类型的技能，包括进攻、防御、恢复等等，每个类型下还可以分为多个子类型（例如，进攻类型下可以分为单体伤害、范围伤害、状态异常等）。还需要考虑不同技能之间的使用条件、CD时间等要素，以便让玩家灵活运用。
2. 技能开发：在程序中对每种技能进行开发，包括技能效果、伤害计算、CD时间等，再加上Visual Effects和音效等，以便在游戏中能够体现出技能的魅力和威力。
3. 技能优化：经过测试，优化技能效果、伤害公式等，以达到更好的平衡和游戏体验。同时，还需要避免一些过于强大的技能或技能组合，以保证游戏的平衡性。
4. 技能获取： 玩家可以从游戏中的任务、副本、商店、成就、掉落等方式，获取新的技能或提升已有技能的等级，以增加战斗中的灵活性和难度。
5. 技能配合：设计技能组合和链式技能，让玩家们能够在战斗中灵活地选用，可以针对不同战斗情况制定最优时间、最优管理技能的策略。

总之，剑与魔法题材的技能系统需要从多个方面考虑，平衡性和游戏体验是非常重要的。最终的目标是能够让玩家在游戏中感受到技能的强大和美妙，同时又不失平衡和公平。

### 20. 蒙太奇系统了解过吗(只有简单使用经历，实现没怎么了解过)
蒙太奇系统是一种常用于影视和游戏制作中的后期剪辑技术，它通过将不同的视频片段以特定的方式组合在一起，来创造出一种新的视觉体验。在游戏制作中，蒙太奇可以用来制作游戏中的过场动画或视频剧情，增强游戏的叙事效果和视觉效果。

以下是实现蒙太奇系统的思路：
1. 视频资源采集：在游戏制作前，需要先采集和准备好所有的视频素材，包括角色动画、场景、特效等。
2. 编辑工具的开发：游戏制作人员需要开发一个统一的编辑工具，以便将不同的视频素材进行蒙太奇组合。这个编辑工具需要提供多种特效和过渡效果，如渐变、淡入淡出、分裂、旋转等等。
3. 时间轴设计：在编辑工具中，需要设计一个时间轴，以便将不同的视频素材安排到不同的时间点上，同时还需要考虑视频的层级关系和播放顺序。
4. 片段的处理：游戏制作人员需要对不同的视频片段进行处理和剖析。这表示要调整不同视频片段的大小、色彩、亮度、对比度等要素，以达到更好的视觉效果。
5. 片段的组合：通过将不同的视频片段按照时间轴的顺序进行组合，并运用各种特效和过渡效果，创建游戏中的过场动画或剧情。

总之，蒙太奇系统需要完成多种技术流程，需具备专业视觉效果制作相关知识，掌握专业的设计和工具使用技巧。通过精细的设计和制作，可以为游戏增添更好的视觉享受，加强游戏的沉浸性和叙事效果，提升满意度。
10. 手游玩过哪些?(刺激战场、全军出击)
### 22. 接上一问，问了刺激战场在手机上的性能优化大概怎么做?
PUBG在手机上的游戏性能优化是一个复杂的过程，以下是一些常见的优化策略：
1. 图形特效优化：游戏开发人员可以通过降低游戏中的一些不必要的特效，如草地细节、雾气效果等，以减少GPU的负荷，提高游戏的帧率和稳定性，同时也能减少电池消耗。可以通过动态加载不同质量的资源，根据不同设备及玩家设定的画质来实现优化。
2. 游戏逻辑优化：游戏中的逻辑计算也需要优化，比如减少冗余计算、优化物理引擎、减少网络通信量等，以提高游戏的性能和响应速度，同时也能减少电量消耗。
3. 内存资源优化：游戏需要考虑设备的内存和硬盘资源。开发人员应尽可能减少游戏在内存中的占用，避免频繁的内存回收，以提高游戏稳定性和响应速度。可以通过更好的资源管理策略，如动态加载、资源回收等方式实现优化。
4. 支持多核CPU：游戏应该支持多核CPU，分配不同的线程来执行不同的计算工作，以充分利用设备性能，提高游戏帧率和稳定性。
5. 网络传输优化：游戏中大量的数据需要通过网络传输。开发人员需要采取优化措施，如压缩数据、减少网络通信量、优化传输协议等，以提高网络传输速度和稳定性，保证游戏的在线体验。
6. 控制电量消耗：在增强游戏品质的同时，还需要考虑手机电池寿命。开发人员可以通过选择更高效的算法、降低特效渲染，优化动态加载、提高CPU效率等措施，尽量减少电池消耗。
7. 设备适配性：游戏在开发过程中应该考虑到不同手机设备的适配性。游戏开发人员可以通过不同的缩放、适配、自动矫正等方案，来解决不同机型的设备适配问题，同时减少开发的成本，提升游戏体验。

以上是PUBG在手机上的性能优化大概的做法，实际的优化过程需要根据具体的渲染系统、设备类型和需求进行，同时还需要经过科学的测试和优化，不断地取得进展。

23. 开始旁敲侧击对于学习新的一门语言和引擎的态度(因为我自己学的是UE,而他们这个项目组是Unity的)
24. 看到我开始的意向是杭州，问了下去成都的意向


反问
问了一下工作强度，问了一下新人指导相关
的问题

![[Pasted image 20240411170505.png]]
# 三面
面试了35min

 2. 为什么选择游戏行业?
 3. 问了一下比赛机制
 4. 和策划合作的感受?
### 5.游戏比赛的开发流程?
游戏比赛的开发流程通常包括以下几个阶段：
1. 规划阶段：游戏比赛的规划阶段是整个开发过程中最重要的阶段。在这个阶段，游戏开发人员需要确定游戏的玩法、规则、奖励机制、计分方式等基本要素，并且制定比赛规则、赛制和时间表。
2. 游戏设计阶段：在游戏设计阶段，游戏开发人员需要根据比赛规则，设计游戏的各个部分，包括玩家角色、场景、任务设计、道具、音效等。
3. 游戏制作阶段：游戏开发人员需要根据游戏设计文档，在视觉和技术方面开始游戏制作。在这个阶段，需要开发游戏的框架和功能模块，并对各个模块进行调试和优化。
4. 测试阶段：完成游戏制作之后，游戏开发人员需要进行全面的测试，以确保游戏的可玩性和稳定性。测试人员会对游戏进行功能测试、兼容性测试、性能测试、安全测试等各方面的测试。
5. 发布阶段：在游戏完成测试后，游戏开发人员需要将游戏正式发布。在此过程中，需要将游戏上传至各大应用商店或游戏网站。
6. 运营阶段：一旦游戏发布，运营阶段就开始了。在这个阶段，游戏运营者需要通过营销和推广活动，吸引更多的玩家来参加比赛，同时更新游戏版本、修复bug、升级游戏特效等，以保持游戏的新鲜度和可玩性。

总之，游戏比赛的开发流程需要游戏开发人员在规划、设计、制作、测试、发布和运营阶段中相互合作和密切关注。每个阶段都需要认真的规划和准备，以确保游戏的质量和可玩性。
 
 6. 学习的途径?(到这我还以为今天就是闲聊呢，还暗自窃喜了一下，果然，哪有这么好的事情，后面果然马上开始上强度简间间)
 7. C++八股
 8. 需求实现环节，和二面一样，面试官提出比如策划给了某某需求，要怎么一步一步去实现需求(这块掰扯了挺久，前面一部分和面试官一边交流一边说想法，总体倒是都答上来了，虽然不知道符不符合面试官的想法，乐;但最后一部分拉了，最后一部分问到了我这个实现具体优化的想法，想了半天没答上来，面试官说考虑多线程的方法，然而我并没有怎么用过多线程，感觉这里面试官有点失望，因为他说UE4其实是一个把多线程玩的很花的引擎，感觉言下之意就是在不满我说自己是学UE4的结果连个多线程都没怎么用过
### 9. UE多线程
UE的多线程主要是通过将任务分配到不同的线程中来实现的，从而可以发挥多核处理器的性能，提高游戏的帧率和效率。
UE中的多线程主要包括两个方面：
1. 游戏逻辑线程：UE使用多线程来处理游戏逻辑，将游戏内的大量计算任务分割成多个小的计算任务，然后分配给不同的线程来处理。这些线程包括渲染线程、物理线程、动画线程等等，在运行时都是独立运行的，能够减少游戏卡顿的情况，提高游戏的帧率和稳定性。
2. 工具和编辑器线程：UE的工具和编辑器部分也使用多线程来提高处理效率。例如，场景编辑器和材质编辑器等一些工具，支持多线程处理大型数据生成、导入、烘焙等一系列操作，使得生成、处理数据的速度更加高效。

总之，UE的多线程技术充分利用了现代硬件平台的性能优势，通过有效地任务分配和利用多核CPU，提高了游戏引擎的效率和性能，让游戏能够更加流畅、高效地运行。同时，UE的多线程设计也有效减少了开发难度和代码维护成本，使得游戏开发人员能够更快速地开发出高质量的游戏。

### 10. 游戏客户端开发是做什么的？
游戏客户端开发主要是指开发出游戏的客户端程序，负责处理游戏玩家在本地进行的操作，将玩家的输入转化为游戏内的动作，负责游戏引擎的运行和游戏界面的渲染等任务。具体来说，游戏客户端开发包括以下内容：

1. 游戏引擎的开发和维护：包括底层渲染、物理引擎、音频引擎等，负责实现游戏的渲染、模拟和处理。
2. 游戏客户端的UI设计和实现：负责实现游戏的菜单、设置、人物属性等各种游戏UI设计。
3. 游戏世界的实现：根据游戏的需求，用游戏引擎实现具体的游戏世界，包括场景、地形、灯光等。
4. 游戏操作和输入的处理：负责将玩家的输入转化为游戏内的动作，并对鼠标、键盘、手柄等设备进行处理。
5. 游戏逻辑处理：通过程序实现游戏规则、任务、关卡等各种游戏逻辑，以及游戏场景中角色受到的影响等其他系统处理。
6. 游戏性能的优化和调试工作：负责优化游戏性能，处理各种潜在的bug和问题，保证游戏的稳定性和流畅性。

综上所述，游戏客户端开发是游戏研发的重要环节之一，需要开发人员具备扎实的编程技能、游戏制作技术和团队协作能力，以实现高质量的游戏体验。

### 11. 游戏服务端开发是做什么的？
游戏服务端开发是游戏研发的另一个重要方面，主要是负责开发和维护游戏服务器端程序，为玩家提供游戏的在线服务。具体来说，游戏服务端开发包括以下工作内容：
1. 连接管理：负责管理和维护客户端和服务端之间的连接，实现用户登录、注销、授权等操作。
2. 数据库设计和维护：设计并维护游戏的数据库，处理用户数据、游戏内容等，确保数据库的安全性和稳定性。
3. 游戏逻辑处理：实现游戏逻辑，如操作记录、成就奖励、游戏难度等，以及各种游戏事件的处理，如角色死亡、任务完成等。
4. 网络通信协议：定义游戏客户端和服务端之间的通信协议，负责报文的解析、封装、发送等操作。
5. 服务端性能优化：通过各种手段对服务端进行优化，提高性能和稳定性，确保游戏顺畅运行。
6. 安全措施：保证游戏内部数据的安全性，防止作弊以及其他不良行为，如重放攻击、数据库注入等。

总之，游戏服务端开发是开发游戏后台基础设施，为用户提供稳定、高效、安全的游戏服务，是游戏开发中至关重要的一环。由于游戏服务端开发需要深入理解网路编程、安全证书和运维等技术，因此需要有一定的技术积累和应对问题的能力。

### 12.作为一位游戏客户端开发程序员，你觉得对于一个开放世界游戏的开发有哪些难点？

1. 游戏场景的设计和优化：开放世界游戏所占用的场景面积较大，那么在设计和优化时，需要考虑到游戏的流畅性和性能问题，避免游戏卡顿或掉帧的情况，同时也要确保游戏场景的细节和真实感。
    
2. 技术实现的复杂度：开放世界游戏需要实现一些非常复杂的功能，如自动化逻辑、AI行为、网络同步等，还要确保这些功能在大量玩家同时在线时能够正常运转。
    
3. 玩家体验的平衡：在开放世界游戏中，玩家将有探索性地决定他们的游戏进度及其表现形式。然而，这样的自由选择会造成一些挑战，例如玩家可能会失去游戏的方向或目标等问题，开发人员需要解决这些问题以确保游戏能够提供令人满意的玩家体验。
    
4. 业务逻辑和游戏系统的实现：开放世界游戏的扩展性是很高的，因此需要大量的游戏系统和业务逻辑，例如故事线、任务和世界建筑物等，需要确保这些系统能够良好地交互，不冲突，不影响玩家的游戏体验。
总之，开放世界游戏的开发复杂度稍高，需要更多的工作量，因此与其他类型的游戏开发相比，它需要更多的资源和时间来设计和实现。
### 13. 对于UE引擎来说，如何做性能优化
UE引擎是一个非常强大的游戏引擎，但是配置不当和不良的编程实践可能会导致性能问题。下面是一些UE引擎的性能优化技巧：
1. 使用Level of Detail（LOD）来减少多边形数。这可以在不降低质量的情况下提高渲染性能，并减少GPU压力。
2. 使用Culling来减少不可见物体的渲染。不可见物体可以被隐藏并跳过渲染，这可以减少需要绘制的物体数量。
3. 使用Batching来减少Draw Call次数。Draw Call是每个物体在渲染时所需要的操作。在这种情况下，将多个物体合并到一个Draw Call中可以减少GPU开销。
4. 减少过多的光源和阴影。这会降低渲染性能，因为光源和阴影的计算非常昂贵。
5. 减少物体的复杂度。复杂的物体会消耗更多的计算资源，所以为减少物体复杂度和面数可以提高渲染性能。
6. 使用纹理的Mip Mapping。逐级缩小纹理可以避免拉伸和失真，并提高渲染性能。
7. 使用游戏中最新的技术和硬件。最新的技术和硬件更高效，可以更好地处理复杂的渲染任务。
    
总之，UE引擎的性能优化需要在每个方面做出细致的考虑。了解每个技巧的优缺点，以及正确地使用和配置引擎，可以帮助提高游戏性能并提高游戏体验。

### 14. UE的多线程在性能优化中好用嘛
UE引擎的多线程架构可以帮助开发人员充分利用多核CPU并提高渲染性能。多线程可以有效地分摊处理负载，并提高代码并发性和效率。下面是一些使用UE引擎的多线程技巧：
1. 在使用多线程之前，请确保你了解多线程开发的基本原则和技巧。多线程在处理上的效率并不是线性的，并且错误地使用多线程会导致死锁、数据竞争、内存泄漏等问题。
2. 使用异步操作来减轻主线程负担。需要在后台中执行的所有长时间运行或高开销操作都可以转换为异步操作，并在另一个线程中执行。这样可以避免长时间挂起主线程，并提高整体性能。
3. 使用FRunnable或FRunnableThread类创建自定义线程并在游戏逻辑中使用。这些类提供了易于使用的API，并且是UE引擎的默认线程类。
4. 使用Task Graph来创建和管理多线程任务。Task Graph系统是UE引擎的主线程任务管理系统，并使用一个专有线程池来提供快捷的多线程操作。
5. 在使用UE引擎的多线程之前，请确保你了解每个线程的作用。例如，渲染线程和主线程之间不应当有竞争或互相阻塞，否则可能会导致出现性能问题。

总之，UE引擎的多线程架构是非常好用且强大的，但是需要注意线程安全等问题，正确地使用和配置引擎可以帮助提高游戏性能并提高游戏体验。

### 15. 能详细介绍UE的多线程架构嘛
UE引擎的多线程架构是由多个线程组成的体系结构，可以帮助开发人员充分利用CPU多核心并提高渲染和游戏逻辑性能。这个架构包括以下线程：
1. 游戏线程：这是主游戏逻辑线程，用于处理游戏逻辑和控制游戏的运行。它在游戏启动时创建，并在游戏运行期间一直存在。
2. 渲染线程：这个线程用于处理渲染和GPU相关的工作。它会在屏幕输出渲染之前执行，在独立于任何其他线程的情况下工作。
3. 任务图线程池：这个线程池允许创建和管理多线程任务。它的核心是Task Graph系统，Task Graph系统会将任务分配给线程池中的可用线程，以便让多线程和并行执行许多必要的计算和操作。
4. 文件异步读取线程：这个线程用于异步读取游戏资源文件。它可以优化内存使用并减少主线程和渲染线程的负担。
5. 运动控制线程：这个线程负责执行物理模拟，只有在物理仿真被运行时才会存在。

在UE引擎中使用多线程的主要优势是可以充分利用现代CPU的多核心，减少单线程处理负载对系统性能的影响，并允许游戏引擎在处理多个任务时进行并行处理。多线程可以提高游戏的整体性能和性能稳定性，但也需要开发人员特别注意线程间同步和数据竞争等线程安全问题，否则可能会导致不稳定或错误行为。


反问
问了面试官觉得作为一个游戏客户端程序员应该掌握的技术栈有哪些，问了面试官平常在玩游戏的时候会不会时刻去关注游戏里的一些功能实现，还是说会一周目单纯体验后面开其他周目的时候再去分析学习



04.14    四面    20min  
破案了，四面似乎是部门大佬面（面试的时候看背景似乎是一个独立的办公室，猜测是部门主管之类的？而且面试官本人一看就有一种大佬的感觉），没问技术，就聊了一些比赛经历，对工作问题的看法等等，就基本闲聊，最后还说对我评价挺高的？还说和HR那边沟通一下尽快推流程（也不知道是不是跟每一个到这面的人都这么说的），不过最后面试官还说希望我能尽早到，并且还强调了游戏客户端只有一个hc，然而本来我是计划五月初再去的，不知道是不是算有点晚了  
来源：牛客网