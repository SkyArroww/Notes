由于跟着爬院的培养计划爬完本科感觉对自己的目标帮助不大，遂不想上课(误)，到头来总之是想找点事干。刚好3月中去看了mhy校招宣讲，看到了一些可能的出路，于是开始海投。可惜的是mhy简历就挂了，莉莉丝面了一轮也挂了，网易叠纸b站啥的一直在审核(都过了半个多月了啊喂！)…………
不过好在鹅厂竟大发慈悲让我过了(感谢马爸爸~），回来记录一下自己的面经与大家共勉~

总的来说，个人的项目经历可聊的部分还是比较多的，于是面试的大部分时间都是围绕项目展开，本贴作不详细叙述，仅记录些更泛化的问题。
每个问题都贴了些ChatGPT 3.5生成的答案供大家参考。
# 一面 24.4.8
忘了记了，总之聊了些自己的项目经历。看我打过一点点OI就没让我写代码(真的写可能就挂了 XD)
# 二面 24.4.12
### 1. 团队合作时某个版本出现问题怎么查？
 **我自己主要答了版本控制相关的方法。**

团队合作时，如果某个版本出现问题，可以采取以下步骤来进行排查：
1. 确认问题: 最初需要做的是确认出现了什么问题。可以描述问题的详细信息，比如出现了什么错误，哪里出现了问题，如何出现了问题。
2. 确认问题的影响范围: 要查明问题是影响了单个团队成员还是所有成员。所有人都能复现问题吗？
3. 检查所有代码更改: 检查最近更新的代码，找出哪一个更改引入了问题。这就需要每个成员都需要仔细检查他们的代码，以确保一切都是符合预期的。
4. 检查日志和监控: 如果每个团队成员都在记录日志，那么日志文件可能会提供一些有关出现问题的线索。另一方面，如果有监控系统的话，可以检查监控信息来了解更多信息。
5. 回滚更改: 如果找到了问题的根源并且该更改可能会影响到其他组件或功能，请考虑回滚更改来修复问题，并重新部署旧版本。
6. 验证修复: 更改后，需要检查是否修复了问题，查看是否还有其他相关问题。
以上步骤可以帮助团队排查问题。如果问题仍然存在，可能需要进一步进行调查并与其他成员协作来解决问题。

以下是快速定位问题的几个步骤：
1. 了解问题所在：先了解问题的性质和出现的环境。如果确定问题只出现在特定环境下，可以缩小问题的范围，有利于快速定位问题。
2. 确认最初的异常信息：对于出现异常或错误的地方，可以先查看控制台的输出或者日志文件，获取异常信息。
3. 逐步缩小问题范围：可以先排除一些常见的问题，如输入错误、配置问题等。然后逐步缩小排查问题的范围。
4. 进行 broken windows 检查：不仅要查找出问题的代码片段，还要查看代码的周围，寻找可能的潜在问题，包括：代码规范是否符合要求、重复代码、重复逻辑等，这些都可能是问题产生的原因。
5. 使用工具：使用调试工具来帮助定位错误，比如断点调试、日志工具、性能监控工具、内存分析工具等。这些工具可以有效提高定位问题的效率。
6. 查找代码历史：使用版本控制工具，查找历史代码，找出可能导致问题的代码变更，这可以帮助找到潜在的缺陷。
7. 与其他开发者协作：与其他开发者协作来定位问题。请将问题描述清楚，让其他人了解情况并提出解决方案。
以上方法可以帮助快速定位问题。实际处理问题时，也可以结合具体情况，采用相应的方法。
### 2.如果版本控制不方便查问题，如何解决？ 
**e.g. 构建一个版本要2个小时，其中有几百次Commit，不方便版本控制进行二分。**

如果版本控制不方便查问题，可以考虑以下方法解决：
1. 进行代码对比：如果版本控制没有记录到关键代码的变更，可以通过代码对比工具，如Winmerge、Beyond Compare、KDiff等，将当前代码和之前的代码进行对比，查找差异。
2. 添加日志输出：如果代码问题不容易通过代码对比的方式找到，可以在代码中添加日志输出，记录关键变量的值，以及程序执行的流程。这样可以在程序出现问题时，通过日志来精确定位问题。
3. 重现问题：当出现问题时，尽可能多地记录有用的信息。比如相关的输入、数据、日志信息等。通过这些信息，可以在同样的环境中重现问题，有助于进一步分析问题。
4. 开展测试：当出现问题时，可以开展针对可能出问题的代码进行测试。可以通过单元测试、集成测试等方式，模拟实际情况，排除问题。
5. 请教其他开发者：如果以上方法均不能解决问题，可以请教其他有经验的开发者，进行技术交流和协作。其他开发者可能会提供新的思路和方案，帮助我们解决问题。
总之，解决问题的方法不只有一种，需要根据具体情况选择合适的方法，才能提高问题解决的效率。
### 3. Debugger的使用？
**没咋用过Debugger，唯一几次也只在CS50x作业里用过。好在大致知道怎么用www**

使用 Debugger 调试工具可以帮助定位和解决代码问题。以下是 Debugger 帮助解决问题的几种情况：
1. 动态查看变量的值：在代码执行的过程中，通过 Debugger 工具可以动态查看变量的值，这有助于进一步理解代码执行流程和分析代码的问题。
2. 断点调试：Debugger 工具支持断点调试功能，可以在代码中设置断点，让代码执行到断点处暂停。这有助于进一步分析代码问题，代码停在断点处时，可以查看各个变量的值是否符合预期，找到代码中可能存在的错误。
3. 定位异常：当代码出现异常时， Debugger 可以帮助我们定位异常并查看异常信息，从而进一步分析和解决问题。
4. 分析程序性能： Debugger 工具可以帮助我们分析程序的性能问题，例如代码的执行耗时、内存占用等。通过分析性能问题，可以找到代码的瓶颈，提高代码的性能。
总之，在代码开发和维护过程中， Debugger 工具可以帮助我们更加快速地定位和解决代码问题，提高代码的质量和效率。
### 4. 对大世界游戏的了解？
**之前看别人面经所以特地提前了解过，主要谈了谈大世界无缝切换的实现方法。**

开放世界游戏（Open world game）是一种游戏类型，特点是给玩家自由探索游戏世界，不受限制的行动自由度，允许玩家自由选择游戏走向和故事发展，而不受严格的剧情线控制。
这种类型的游戏通常将游戏世界设计得非常详细和庞大，玩家可以自由探索，参与各种任务与活动，并与世界上其他角色互动。此外，然后也会囊括养成、装备收集、升级、解谜、交互等多种玩法，让玩家可以根据自己的兴趣和喜好自由选择自己想要的游戏内容。
知名的开放世界游戏有《上古卷轴5：天际》、《巫师3：狂猎》、《GTA5》、《荒野大镖客故事2》等。这类游戏通常需要较长的游戏时间和深厚的游戏经验，需要玩家花费大量时间和精力细心地探索和玩耍。

从技术层面上看，开放世界游戏有以下实现难点：
1. 场景加载优化：开放世界游戏通常需要大量的场景和地图，这使得实时加载和渲染成为必要的技术。游戏引擎需要使用高效的算法和数据结构，以及逐帧加载、碰撞检测等优化措施，以确保游戏场景的流畅性和稳定性。
2. 数据管理优化：开放世界游戏通常有很多任务、道具、角色等复杂的游戏数据需要处理。游戏引擎需要具备高效的数据管理和存储功能，从而实现游戏数据的高速读取和快速处理。
3. 人物行为设计：开放世界游戏需要处理大量的 NPC（Non-playable character）和 AI（Artificial Intelligence）等人物行为。游戏引擎需要具备高级的AI技术和算法，从而实现自动控制、人工智能、自适应行为等优化措施，确保游戏角色的真实、逼真、灵活的运动。
4. 资源优化：开放世界游戏通常需要大量的场景建模、音效和画面特效等资源。游戏引擎需要具备高效的资源处理和优化技术，从而减小游戏的存储空间和网络带宽占用，同时实现高品质的音效和画面渲染效果。
5. 多线程调度：开放世界游戏的运行需要考虑多线程和分布式计算问题，通常需要协调多个进程、多个计算节点和多个设备，以实现高并发和高性能运行。游戏引擎需要具备高级的多线程调度和并行计算技术，确保不同计算任务之间的协同和协调。

# 三面 24.4.16
### 0. 对游戏行业不景气的看法？
**讲了讲政策的相关问题，然后表达信心www**

当前的游戏行业确实不太景气，主要原因有以下几个方面：
1. 竞争加剧：现在市场上有越来越多的游戏公司和游戏产品，竞争越来越激烈，游戏公司之间也在不断地抢夺市场份额。因此，如果游戏公司的产品质量不过关或者缺乏创新，就会失去市场竞争力，遭受巨大的冲击。
2. 游戏市场饱和：现在游戏市场已经饱和，玩家数量饱和，流量红利逐渐消失，新用户增速放缓，游戏终端的更新也变慢。这就意味着，游戏公司需要更多地面对竞争和分配有限的时间和金钱资源。
3. 游戏开发成本高：随着游戏行业的发展，游戏开发成本也愈发高昂。比如一些大型的游戏需要投入数亿的研发成本，也需要大量的人力和物力资源去支撑。在这种情况下，一些中小型游戏公司可能很难承受。

尽管如此，游戏行业依然有很多发展机会。游戏市场是一个快速变化的市场，新技术和新玩法在不断涌现，如果游戏公司能够抓住新技术和新玩法的机会，创新新的游戏模式，也能够在市场上获得成功。同时，游戏产业的链条也在不断拓展，从游戏开发到游戏维护，从游戏运营到游戏推广，都是游戏公司可以深度参与的领域，游戏的产业链条也越来越完整。大量的玩家、庞大的市场和未来游戏技术的不断进步都为游戏产业带来许多发展机遇，只要坚持创新、追踪趋势，就能够在这个产业中占有一席之地。

### 1. 野指针是什么？出现的原因以及避免的方法？
在C++中，野指针是指指向未知内存地址或已经释放的内存地址的指针。当程序尝试读写这些野指针的时候，通常会导致程序出现UAF（使用未分配）或者访问其他的内存区域而导致不可预知的错误，因此野指针是C++程序中常见的错误之一。
出现野指针的原因有很多，比如：
1. 未初始化指针：指针变量在定义时没有初始化，或者没有赋值，可能会包含随机的内存地址，导致野指针。
2. 重复释放内存：指针一旦释放，内存就会被系统回收，如果在之后的程序中继续使用这个指针，就会成为野指针。
3. 悬垂指针：指向已经被释放的内存地址，这些地址可能已分配给其他对象，一旦通过悬垂指针操作这个指针，就可能会出现错误。

在避免野指针方面，有以下几个建议：
1. 及时初始化指针，尤其是定义为局部变量的指针，不要留给它们成为野指针的机会。
2. 在释放指针后及时将指针设置为nullptr，防止访问野指针。
3. 尽量使用自动变量和智能指针，避免手动管理内存分配和释放。
4. 使用动态内存分配后，需要确保释放内存时需要释放全部的内存，而不是只释放部分内存，避免重复释放。

总之，避免野指针是C++编程的重要一环，需要编写高质量的代码，确保安全，可维护，并避免出现不必要的错误和异常。

在程序中，指针可以说是非常重要的一个概念，它提供了对变量或对象的直接访问，这对于某些情况下的实现非常有用且高效。但是指针也是一把双刃剑，它的不当使用也很容易导致一些问题，其中最常见的问题之一就是野指针。

野指针指的是一个指针并不指向一个有效的对象或变量，如同“野生”的动物一样，这个指针非常危险，可以引起各种错误。野指针出现的原因往往是程序员对指针的不当使用，具体来说，可能有以下几个原因：
1. 指针未初始化：在使用一个指针变量之前，应该先赋初值或者将其设置为NULL，如果没有这样做，那么指向该指针的地址就是不确定的，可能导致指针指向的地址非法，产生野指针。
2. 指针越界：指针指向的地址范围应该是有效的，如果指针指向了一个超出了其所在对象（数组或结构体）的地址范围，则引用该指针就会产生错误。
3. 对已释放的对象使用指针引用：程序员应养成一个好习惯，即在使用完动态申请的内存后，应该及时释放这些内存，否则就可能会出现对已经释放的内存进行访问操作，产生野指针。
4. 指针误用：指针可以表示多种意义，如果将一个指向字符串的指针，通过加减运算或强制转换等操作，用于其他类型变量，那么就可能引发误用，产生野指针。

总之，要避免野指针的出现，需要程序员养成良好的编程习惯，一方面避免使用未初始化的指针或越界的指针，另一方面，在释放动态申请的内存后，要把该指针清空，防止继续使用。
### 2. 操作系统中内存的分部是怎么样的？
内存的划分在操作系统中非常重要，主要涉及到操作系统与进程的关系，以及内存管理的实现。一般来说，内存的划分可以分为以下几个部分：
1. 内核区域：内核区域是操作系统专用的内存区域，用于存储程序的核心部分，包括操作系统内核的代码和数据等。这个区域通常是在系统初始化时直接分配的，是系统的最高权限，只有操作系统才能访问。
2. 用户区域：用户区域是进程可以访问的内存区域，用于存储用户程序的代码和数据等。用户程序运行时，需要保证内存区域的连续性，并且避免和其他进程相互干扰。
3. 共享库区域：共享库是一些被多个程序使用的代码和数据的集合，它们通常被加载到共享库区域。如果一个进程调用了共享库中的函数，那么这个函数的代码和数据就在共享库区域中寻找，从而避免了重复的代码和数据浪费。
4. 堆区域：堆区域用于存储程序运行时动态分配的内存，通常是通过库函数（如malloc、calloc等）实现的，是由程序员自行管理的。
5. 栈区域：栈区域用于存储程序运行时需要的一些临时数据，比如函数调用时的参数、返回值等，通常由编译器进行管理和分配内存。

需要注意的是，内存的划分在不同的操作系统和架构上可能会有所不同，但是大致原则是相同的。内存的划分对于操作系统和程序的性能和稳定性非常重要，对于编写高效、可靠的程序也有着非常重要的影响。
### 3. 内存对齐是什么？
内存对齐是计算机中一种重要的概念，指的是在分配内存时按照特定的规则将对象的起始地址对齐到某个特定值的过程。内存对齐可以提高计算机程序执行的效率，并且是操作系统和编译器必须考虑的因素之一。下面介绍一下内存对齐的基本概念：
1. 对齐边界：对齐边界是指要求对象的起始地址必须是某个值的整数倍，这个值也称为对齐单位，通常是2、4、8、16等。
2. 对象大小：对象的大小是指该对象所占用的内存大小，通常也是对齐边界的整数倍。
3. 对齐填充：对齐填充指的是将一个对象的大小增加到对齐边界的整数倍，这样可以保证下一个对象分配的空间是对齐的。

为什么要进行内存对齐呢？主要是因为：
1. 提高读取速度：计算机在内存中读取数据时，往往是按照一定的块大小读取的，如果对象的起始地址不是对齐的，则要读取两个块的数据，浪费了一些时间。
2. 提高缓存命中率：现代计算机中都有缓存机制，如果对齐到一个缓存块大小，那么就可以让一个缓存块存储多个对象，增大缓存命中的可能性。
3. 提高硬件平台的兼容性：不同的硬件平台要求的对齐方式可能不同，通过进行内存对齐可以增加程序的可移植性。

需要注意的是，内存对齐也可能会产生一些副作用，比如在数组或结构体中进行对齐填充时可能会浪费空间，还可能会增加内存碎片。因此，在进行内存分配和对齐时必须谨慎考虑，权衡效率和空间的利用率。

### 4. 内存对齐后为什么存取操作会快一点？
内存对齐能提高读取速度的原因主要是因为当数据被访问时，计算机会按照一定的块大小从内存中读取数据，这个块大小也被称为缓存块或缓存行。当要读取一个未对齐的内存位置中的数据时，可能会跨越多个缓存块，需要进行额外的寻址和读取操作，这种情况会增加读取操作的时间。

举一个简单的例子，假设缓存块大小为8个字节，现在要在内存中读取一个未对齐的整数，其地址是0x00000005。则计算机需要读取两个缓存块，分别是0x00000000~~0x00000007和0x00000008~~0x0000000F，然后计算机会将这两个缓存块合并，再从合并后的结果中获取所需的数据。这个过程需要进行额外的寻址和读取，会降低读取速度。

而如果将这个整数的地址对齐到8的倍数，比如0x00000008，那么计算机只需要读取一个缓存块，速度会快很多。因此，内存对齐能提高读取速度的原因就是减少了额外处理的缓存块数量和节省了额外处理的时间。

需要注意的是，内存对齐能够提高读取速度的效果可能会因不同的硬件架构和操作系统而有所不同，因此在进行程序优化时需要对多个平台进行充分测试和评估。

### 5. 对于二维数组，行/列遍历速度会有差异嘛？
是的，对于二维数组，行/列遍历的顺序可能会对程序的执行效率产生影响。

在内存中，二维数组是按行优先或列优先存储的。按行优先存储的数组是将每一行的所有元素顺序存储在连续的内存地址中，按列优先存储的数组则是将每一列的所有元素顺序存储在连续的内存地址中。因此，按行遍历的数组访问的是连续的内存地址，对于缓存机制的利用更好，可能会比按列遍历的速度快。

但是，行和列的遍历速度的差异取决于具体的代码实现和硬件平台。在有些情况下，按列遍历二维数组可能会比按行遍历更快。例如，当数组太大以至于无法完全缓存时，按列遍历可能会减少缓存错失率；而当数组元素的大小非常大时，按行遍历可能会减少缓存错失率，因为每一行中连续的元素可能被缓存到同一个缓存块中。

因此，在选择遍历二维数组的顺序时，需要根据具体情况进行评估和测试，选取最优的方案。此外，还有些技巧可以用来提高二维数组的性能，例如将数据转换为行优先或列优先存储，尽量减少内存分配和释放的次数，采用矩阵加速库等等。
### 6. 对于游戏引擎的理解
**之前也准备了UE和Unity引擎的概述，所以详细说了说**

引擎是指一类专门用于游戏或应用程序开发的软件框架，提供了一系列工具和库，以便开发人员能够快速、高效地开发出更好的游戏或应用程序。
在游戏开发方面，引擎的主要作用就是提供游戏开发所需的各种基础设施，如图形渲染、物理模拟、碰撞检测、音效系统等，使得开发人员能够更加专注于游戏本身的逻辑和玩法开发，而不必花费大量的时间和精力去编写这些基础设施。
除此之外，引擎还提供了一些额外的功能，如跨平台支持、可视化编辑器、脚本语言支持、网络编程等，以便开发人员能够开发出适应不同平台、不同需求的游戏和应用程序。
目前，市面上较为常见的游戏引擎包括Unity、Unreal Engine、Cocos2d、CryEngine等。这些引擎都具有各自独特的特点和优势，开发人员可以根据自身的需求和技能水平选择合适的引擎进行开发。
总体而言，引擎是游戏开发中不可或缺的基础设施，能够为开发者提供重要的工具和库，使得游戏开发更加高效、便捷、灵活。

Unreal Engine（UE）的引擎实现主要包括以下几个方面：

1. 渲染引擎：UE的渲染引擎使用了最新的渲染技术，包括DirectX 12和Vulkan等，同时也支持OpenGL和Metal。UE的渲染引擎可以定制化，开发者可以根据自己的需求和平台特性来进行修改，以达到更好的游戏性能和视觉效果。
2. 物理引擎：UE的物理引擎基于NVIDIA的PhysX引擎进行开发，支持实时碰撞检测、重力模拟、角色动画等功能。物理引擎支持多种材质，如金属、木材、石材等，并且可以扩展新的材质。
3. 音效引擎：UE的音效引擎支持3D音效、接口音效和音频解码等多项功能。音效引擎在PC和主机等平台上都提供了高质量、低延时的音效效果。
4. 关卡编辑器：UE的关卡编辑器是一款全面的可视化编辑器，可用于创建游戏关卡。通过该编辑器，开发者可以轻松创建具有复杂地形、大量动态实体和粒子效果的游戏关卡。
5. 蓝图系统：UE的蓝图系统是基于节点的可视化编程框架，可用于设计和创建游戏逻辑。通过该系统，开发者可以在不编写任何代码的情况下创建复杂的游戏逻辑，包括人物AI、战斗系统、交互操作等。
6. 网络引擎：UE的网络引擎可以在游戏中处理多种网络功能，如多人游戏、匹配模式、统计和实时通信等。其网络架构支持客户端/服务器模式和点对点模式，可以使用TCP和UDP协议进行通信。
7. 脚本语言：UE支持多种脚本语言，包括C++和Blueprint蓝图，还支持Python、JavaScript等语言的扩展。脚本语言可用于快速创建游戏逻辑和工具，增强了UE的灵活性。

Unity的引擎实现主要包括以下几个方面：
1. 渲染引擎：Unity的渲染引擎支持多种图形API，如DirectX、OpenGL、Metal等。同时还支持着色器和屏幕空间反射等渲染技术，以及全局光照和实时阴影等功能。
2. 物理引擎：Unity的物理引擎基于NVIDIA的PhysX引擎进行开发，支持碰撞检测、重力模拟、角色动画等功能，同时还支持柔体动力学技术。
3. 音效引擎：Unity的音效引擎支持3D音效、复杂混音、音效距离与衰减等功能，同时还支持音频剪辑和实时变换等。
4. 关卡编辑器：Unity的关卡编辑器提供了一个可视化编辑器界面，能够支持开发者创建地形和布置场景。
5. 脚本语言：Unity的主要脚本语言是C#，但也支持JavaScript和Boo等语言。C#语言的运行速度较快，而且可以嵌入其他.NET技术。
6. 网络引擎：Unity的网络引擎支持多种网络功能，包括多人游戏、服务器托管和实时通信等，可以使用TCP和UDP协议进行通信。同时，Unity还支持第三方框架和云服务。

与UE相比，Unity的优点在于其较为轻量和易用，且开发效率高。Unity采用了Component-Entity架构，可组件化和模块化开发，能够快速迭代游戏，同时还支持多平台发布和一键迭代。在移动游戏领域，Unity已经成为了主流的开发引擎。

而UE则以其强大的渲染和物理引擎、可自定义性和精度等方面脱颖而出，在3A大型游戏领域具有优势。UE拥有更强大的关卡编辑器、蓝图系统以及更高质量的视觉效果，同时对物理模拟支持更加全面，具有更好的游戏性能和效果。
### 7. 对团队合作的了解
感觉这是个很重要的问题，每次面试都会问到你与其他同学合作的经历，作为组长组员在遇到问题时怎么做，大家可以多根据自己的经验准备准备。
### 8. 遇到bug怎么办？
详见二面相关问题。

反问：
	如何自学游戏相关？
A：
	游戏行业门槛低，但上限高。e.g.对于UI，要想很多方法实现它以保证性能最优，能在低端机上流畅运行。相比于拓展知识的宽度，更建议对某一方面深入了解……


# HR面 24.4.17
也是先聊了聊自己的项目相关和学院相关...
### 1. 你经历过压力最大的事是什么？
**RM，没有之一……**
### 2. 被分配到任务时，你会怎么做？
**分自己熟悉和不熟悉两方面答了答**

# 云证 24.4.19
# OC 24.4.22